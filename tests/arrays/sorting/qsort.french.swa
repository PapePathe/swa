dialecte:fran√ßais;

// ------------------------------------
// PARTITION FUNCTION (Helper for QuickSort)
// Rearranges the array elements around a pivot.
// Returns the index of the pivot element.
// ------------------------------------
fonction partition(list: [5]entier, low: entier, high: entier) entier {
  variable pivot: entier = list[high]; // Choose the rightmost element as the pivot
  variable i: entier = low - 1;        // Index of smaller element
  variable j: entier = low;
  
  // Custom temporary variable for swapping (SWA doesn't show multiple assignment)
  variable temp: entier = 0; 

  tantque(j < high) {
    si(list[j] < pivot) {
      i = i + 1;
      
      // SWAP: list[i] and list[j]
      temp = list[i];
      list[i] = list[j];
      list[j] = temp;
    }
    j = j + 1;
  }
  
  // SWAP: list[i+1] and pivot (list[high])
  temp = list[i + 1];
  list[i + 1] = list[high];
  list[high] = temp;

  retourner i + 1; // Return the partitioning index
}

// ------------------------------------
// QUICKSORT FUNCTION (Recursive Sorting)
// ------------------------------------
fonction quickSort(list: [5]entier, low: entier, high: entier) entier {
  variable pi: entier = 0;

  si(low < high) {
    // pi is the partitioning index, list[pi] is now in the correct place
    pi = partition(list, low, high);

 //   // Recursively sort elements before and after partition
    quickSort(list, low, pi - 1);
    quickSort(list, pi + 1, high);
  }
  
  retourner 0; // Return the modified array
}


demarrer () entier {
  // Array to sort: 
  variable unsorted_list: [5]entier = [5]entier{5, 4, 3, 2, 1};
  variable idx: entier = 0;
  
  quickSort(unsorted_list, 0, 4); 

  afficher("Sorted List: ");
  tantque(idx < 5) {
    afficher("%d ", unsorted_list[idx]);
    idx = idx + 1;
  }
  
  retourner 0; 
}
