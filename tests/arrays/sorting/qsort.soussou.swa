khuien:soussou;

// ------------------------------------
// PARTITION FUNCTION (Helper for QuickSort)
// Rearranges the array elements around a pivot.
// Returns the index of the pivot element.
// ------------------------------------
wali partition(list: [5]konti, low: konti, high: konti) konti {
  kouicé pivot: konti = list[high]; // Choose the rightmost element as the pivot
  kouicé i: konti = low - 1;        // Index of smaller element
  kouicé j: konti = low;
  
  // Custom temporary variable for swapping (SWA doesn't show multiple assignment)
  kouicé temp: konti = 0; 

  be(j < high) {
    xa(list[j] < pivot) {
      i = i + 1;
      
      // SWAP: list[i] and list[j]
      temp = list[i];
      list[i] = list[j];
      list[j] = temp;
    }
    j = j + 1;
  }
  
  // SWAP: list[i+1] and pivot (list[high])
  temp = list[i + 1];
  list[i + 1] = list[high];
  list[high] = temp;

  gbilen i + 1; // Return the partitioning index
}

// ------------------------------------
// QUICKSORT FUNCTION (Recursive Sorting)
// ------------------------------------
wali quickSort(list: [5]konti, low: konti, high: konti) konti {
  kouicé pi: konti = 0;

  xa(low < high) {
    // pi is the partitioning index, list[pi] is now in the correct place
    pi = partition(list, low, high);

 //   // Recursively sort elements before and after partition
    quickSort(list, low, pi - 1);
    quickSort(list, pi + 1, high);
  }
  
  gbilen 0; // Return the modified array
}


sodé () konti {
  // Array to sort: 
  kouicé unsorted_list: [5]konti = [5]konti{5, 4, 3, 2, 1};
  kouicé idx: konti = 0;
  
  quickSort(unsorted_list, 0, 4); 

  masen("Sorted List: ");
  be(idx < 5) {
    masen("%d ", unsorted_list[idx]);
    idx = idx + 1;
  }
  
  gbilen 0; 
}
