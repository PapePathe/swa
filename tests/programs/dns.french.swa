dialecte:fran√ßais;

// ==================== DNS CONSTANTS AND STRUCTURES ====================

// DNS Resource Record Types
variable DNS_TYPE_A: entier = 1;
variable DNS_TYPE_NS: entier = 2;
variable DNS_TYPE_CNAME: entier = 5;
variable DNS_TYPE_SOA: entier = 6;
variable DNS_TYPE_PTR: entier = 12;
variable DNS_TYPE_MX: entier = 15;
variable DNS_TYPE_TXT: entier = 16;
variable DNS_TYPE_AAAA: entier = 28;
variable DNS_TYPE_SRV: entier = 33;

// DNS Classes
variable DNS_CLASS_IN: entier = 1;
variable DNS_CLASS_CS: entier = 2;
variable DNS_CLASS_CH: entier = 3;
variable DNS_CLASS_HS: entier = 4;

// DNS Response Codes
variable DNS_RCODE_NOERROR: entier = 0;
variable DNS_RCODE_FORMERR: entier = 1;
variable DNS_RCODE_SERVFAIL: entier = 2;
variable DNS_RCODE_NXDOMAIN: entier = 3;
variable DNS_RCODE_NOTIMP: entier = 4;
variable DNS_RCODE_REFUSED: entier = 5;

// DNS Message Structure
structure DNSHeader {
  id: entier,
  qr: entier,
  opcode: entier,
  aa: entier,
  tc: entier,
  rd: entier,
  ra: entier,
  z: entier,
  rcode: entier,
  qdcount: entier,
  ancount: entier,
  nscount: entier,
  arcount: entier,
}

structure DNSQuestion {
  name: chaine,
  type: entier,
  class: entier,
}

structure DNSResourceRecord {
  name: chaine,
  type: entier,
  class: entier,
  ttl: entier,
  rdlength: entier,
  rdata: [512]entier,
  rdata_str: chaine,
}

structure DNSMessage {
  header: DNSHeader,
  questions: [10]DNSQuestion,
  answers: [20]DNSResourceRecord,
  authorities: [10]DNSResourceRecord,
  additionals: [10]DNSResourceRecord,
  question_count: entier,
  answer_count: entier,
  authority_count: entier,
  additional_count: entier,
  raw_data: [512]entier,
  raw_length: entier,
}

structure DNSCacheEntry {
  name: chaine,
  type: entier,
  class: entier,
  ttl: entier,
  data: [512]entier,
  data_length: entier,
  timestamp: entier,
}

structure DNSCache {
  entries: [100]DNSCacheEntry,
  entry_count: entier,
  max_entries: entier,
}

// ==================== UTILITY FUNCTIONS ====================

fonction int_to_string(num: entier) chaine {
  si (num == 0) {
    retourner "0";
  }
  
  variable result: chaine = "";
  variable temp: entier = num;
  variable is_negative: entier = 0;
  
  si (temp < 0) {
    is_negative = 1;
    temp = 0 - temp;
  }
  
  variable done: entier = 0;
  tantque (done == 0) {
    si (temp == 0) {
      done = 1;
    } sinon {
      variable digit: entier = temp % 10;
      variable digit_str: chaine = "";
      si (digit == 0) { digit_str = "0"; }
      si (digit == 1) { digit_str = "1"; }
      si (digit == 2) { digit_str = "2"; }
      si (digit == 3) { digit_str = "3"; }
      si (digit == 4) { digit_str = "4"; }
      si (digit == 5) { digit_str = "5"; }
      si (digit == 6) { digit_str = "6"; }
      si (digit == 7) { digit_str = "7"; }
      si (digit == 8) { digit_str = "8"; }
      si (digit == 9) { digit_str = "9"; }
      
      result = digit_str + result;
      temp = temp / 10;
    }
  }
  
  si (is_negative == 1) {
    result = "-" + result;
  }
  
  retourner result;
}

fonction string_to_int(str: chaine) entier {
  variable result: entier = 0;
  variable i: entier = 0;
  variable is_negative: entier = 0;
  
  si (str.length > 0) {
    si (str[0] == "-") {
      is_negative = 1;
      i = 1;
    }
  }
  
  tantque (i < str.length) {
    variable ch: chaine = str[i];
    variable digit: entier = 0;
    
    si (ch == "0") { digit = 0; }
    si (ch == "1") { digit = 1; }
    si (ch == "2") { digit = 2; }
    si (ch == "3") { digit = 3; }
    si (ch == "4") { digit = 4; }
    si (ch == "5") { digit = 5; }
    si (ch == "6") { digit = 6; }
    si (ch == "7") { digit = 7; }
    si (ch == "8") { digit = 8; }
    si (ch == "9") { digit = 9; }
    
    result = result * 10 + digit;
    i = i + 1;
  }
  
  si (is_negative == 1) {
    result = 0 - result;
  }
  
  retourner result;
}

fonction get_rr_type_name(type_val: entier) chaine {
  si (type_val == DNS_TYPE_A)    { retourner "A";    } 
  si (type_val == DNS_TYPE_NS)   { retourner "NS"; }
  si (type_val == DNS_TYPE_CNAME){ retourner "CNAME";}
  si (type_val == DNS_TYPE_SOA)  { retourner "SOA";}
  si (type_val == DNS_TYPE_PTR)  { retourner "PTR";}
  si (type_val == DNS_TYPE_MX)   { retourner "MX";}
  si (type_val == DNS_TYPE_TXT)  { retourner "TXT";}
  si (type_val == DNS_TYPE_AAAA) { retourner "AAAA";}
  si (type_val == DNS_TYPE_SRV)  { retourner "SRV";}
  retourner "TYPE_" + int_to_string(type_val);
}

fonction get_rr_class_name(class_val: entier) chaine {
  si (class_val == DNS_CLASS_IN) { retourner "IN"; }
  si (class_val == DNS_CLASS_CS) { retourner "CS"; } 
  si (class_val == DNS_CLASS_CH) { retourner "CH"; }
  si (class_val == DNS_CLASS_HS) { retourner "HS"; }
  retourner "CLASS_" + int_to_string(class_val);
}

fonction get_rcode_name(rcode_val: entier) chaine {
  si (rcode_val == DNS_RCODE_NOERROR) { retourner "NOERROR";}
  si (rcode_val == DNS_RCODE_FORMERR) { retourner "FORMERR";}
  si (rcode_val == DNS_RCODE_SERVFAIL){ retourner "SERVFAIL";}
  si (rcode_val == DNS_RCODE_NXDOMAIN){ retourner "NXDOMAIN";}
  si (rcode_val == DNS_RCODE_NOTIMP)  { retourner "NOTIMP";}
  si (rcode_val == DNS_RCODE_REFUSED) { retourner "REFUSED";}
  retourner "RCODE_" + int_to_string(rcode_val);
}

fonction byte_to_hex(byte_val: entier) chaine {
  variable high_nibble: entier = byte_val / 16;
  variable low_nibble: entier = byte_val % 16;
  variable high_char: chaine = "";
  variable low_char: chaine = "";
  
  si (high_nibble == 0) { high_char = "0"; }
  si (high_nibble == 1) { high_char = "1"; }
  si (high_nibble == 2) { high_char = "2"; }
  si (high_nibble == 3) { high_char = "3"; }
  si (high_nibble == 4) { high_char = "4"; }
  si (high_nibble == 5) { high_char = "5"; }
  si (high_nibble == 6) { high_char = "6"; }
  si (high_nibble == 7) { high_char = "7"; }
  si (high_nibble == 8) { high_char = "8"; }
  si (high_nibble == 9) { high_char = "9"; }
  si (high_nibble == 10) { high_char = "A"; }
  si (high_nibble == 11) { high_char = "B"; }
  si (high_nibble == 12) { high_char = "C"; }
  si (high_nibble == 13) { high_char = "D"; }
  si (high_nibble == 14) { high_char = "E"; }
  si (high_nibble == 15) { high_char = "F"; }
  
  si (low_nibble == 0) { low_char = "0"; }
  si (low_nibble == 1) { low_char = "1"; }
  si (low_nibble == 2) { low_char = "2"; }
  si (low_nibble == 3) { low_char = "3"; }
  si (low_nibble == 4) { low_char = "4"; }
  si (low_nibble == 5) { low_char = "5"; }
  si (low_nibble == 6) { low_char = "6"; }
  si (low_nibble == 7) { low_char = "7"; }
  si (low_nibble == 8) { low_char = "8"; }
  si (low_nibble == 9) { low_char = "9"; }
  si (low_nibble == 10) { low_char = "A"; }
  si (low_nibble == 11) { low_char = "B"; }
  si (low_nibble == 12) { low_char = "C"; }
  si (low_nibble == 13) { low_char = "D"; }
  si (low_nibble == 14) { low_char = "E"; }
  si (low_nibble == 15) { low_char = "F"; }
  
  retourner high_char + low_char;
}

fonction ascii_to_char(code: entier) chaine {
  si (code == 32){ retourner " ";}
  si (code == 33){ retourner "!";}
  si (code == 34){ retourner "\"";}
  si (code == 35){ retourner "#";}
  si (code == 36){ retourner "$";}
  si (code == 37){ retourner "%";}
  si (code == 38){ retourner "&";}
  si (code == 39){ retourner "'";}
  si (code == 40){ retourner "(";}
  si (code == 41){ retourner ")";}
  si (code == 42){ retourner "*";}
  si (code == 43){ retourner "+";}
  si (code == 44){ retourner ",";}
  si (code == 45){ retourner "-";}
  si (code == 46){ retourner ".";}
  si (code == 47){ retourner "/";}
  si (code == 58){ retourner ":";}
  si (code == 59){ retourner ";";}
  si (code == 60){ retourner "<";}
  si (code == 61){ retourner "=";}
  si (code == 62){ retourner ">";}
  si (code == 63){ retourner "?";}
  si (code == 64){ retourner "@";}
  si (code == 91){ retourner "[";}
  si (code == 92){ retourner "\\";}
  si (code == 93){ retourner "]";}
  si (code == 94){ retourner "^";}
  si (code == 95){ retourner "_";}
  si (code == 96){ retourner "`";}
  si (code == 123){ retourner "{";}
  si (code == 124){ retourner "|";}
  si (code == 125){ retourner "}";}
  si (code == 126){ retourner "~";}
  
  si (code >= 48 && code <= 57) {
    retourner int_to_string(code - 48);
  }
  
  si (code >= 65 && code <= 90) {
    variable letter_num: entier = code - 65;
    si (letter_num == 0){ retourner "A"; }
    si (letter_num == 1){ retourner "B"; }
    si (letter_num == 2){ retourner "C"; }
    si (letter_num == 3){ retourner "D"; }
    si (letter_num == 4){ retourner "E"; }
    si (letter_num == 5){ retourner "F"; }
    si (letter_num == 6){ retourner "G"; }
    si (letter_num == 7){ retourner "H"; }
    si (letter_num == 8){ retourner "I"; }
    si (letter_num == 9){ retourner "J"; }
    si (letter_num == 10) { retourner "K"; }
    si (letter_num == 11) { retourner "L";} 
    si (letter_num == 12) { retourner "M";} 
    si (letter_num == 13) { retourner "N";} 
    si (letter_num == 14) { retourner "O";} 
    si (letter_num == 15) { retourner "P";} 
    si (letter_num == 16) { retourner "Q";} 
    si (letter_num == 17) { retourner "R";} 
    si (letter_num == 18) { retourner "S";} 
    si (letter_num == 19) { retourner "T";} 
    si (letter_num == 20) { retourner "U";} 
    si (letter_num == 21) { retourner "V";} 
    si (letter_num == 22) { retourner "W";} 
    si (letter_num == 23) { retourner "X";} 
    si (letter_num == 24) { retourner "Y";} 
    retourner "Z";
  }
  
  si (code >= 97 && code <= 122) {
    variable letter_num: entier = code - 97;
    si (letter_num == 0)  { retourner "a";} 
    si (letter_num == 1)  { retourner "b";}
    si (letter_num == 2)  { retourner "c";}
    si (letter_num == 3)  { retourner "d";}
    si (letter_num == 4)  { retourner "e";}
    si (letter_num == 5)  { retourner "f";}
    si (letter_num == 6)  { retourner "g";}
    si (letter_num == 7)  { retourner "h";}
    si (letter_num == 8)  { retourner "i";}
    si (letter_num == 9)  { retourner "j";}
    si (letter_num == 10) { retourner "k";}
    si (letter_num == 11) { retourner "l";}
    si (letter_num == 12) { retourner "m";}
    si (letter_num == 13) { retourner "n";}
    si (letter_num == 14) { retourner "o";}
    si (letter_num == 15) { retourner "p";}
    si (letter_num == 16) { retourner "q";}
    si (letter_num == 17) { retourner "r";}
    si (letter_num == 18) { retourner "s";}
    si (letter_num == 19) { retourner "t";}
    si (letter_num == 20) { retourner "u";}
    si (letter_num == 21) { retourner "v";}
    si (letter_num == 22) { retourner "w";}
    si (letter_num == 23) { retourner "x";}
    si (letter_num == 24) { retourner "y";}
    retourner "z";
  }
  
  retourner ".";
}

// ==================== DNS NAME ENCODING/DECODING ====================

fonction encode_dns_name(domain: chaine) [256]entier {
  variable encoded: [256]entier = [256]entier{0};
  variable encoded_idx: entier = 0;
  variable domain_idx: entier = 0;
  variable label_start: entier = 0;
  variable label_length: entier = 0;
  variable done_encoding: entier = 0;
  
  tantque (done_encoding == 0) {
    variable ch: chaine = "";
    si (domain_idx < domain.length) {
      ch = domain[domain_idx];
    }
    
    si (domain_idx == domain.length) {
      encoded[label_start] = label_length;
      
      variable i: entier = 0;
      variable copy_done: entier = 0;
      tantque (copy_done == 0) {
        si (i == label_length) {
          copy_done = 1;
        } sinon {
          variable label_char: chaine = domain[label_start + 1 + i];
          variable char_code: entier = 0;
          
          si (label_char == "a") { char_code = 97; }
          si (label_char == "b") { char_code = 98; }
          si (label_char == "c") { char_code = 99; }
          si (label_char == "d") { char_code = 100; }
          si (label_char == "e") { char_code = 101; }
          si (label_char == "f") { char_code = 102; }
          si (label_char == "g") { char_code = 103; }
          si (label_char == "h") { char_code = 104; }
          si (label_char == "i") { char_code = 105; }
          si (label_char == "j") { char_code = 106; }
          si (label_char == "k") { char_code = 107; }
          si (label_char == "l") { char_code = 108; }
          si (label_char == "m") { char_code = 109; }
          si (label_char == "n") { char_code = 110; }
          si (label_char == "o") { char_code = 111; }
          si (label_char == "p") { char_code = 112; }
          si (label_char == "q") { char_code = 113; }
          si (label_char == "r") { char_code = 114; }
          si (label_char == "s") { char_code = 115; }
          si (label_char == "t") { char_code = 116; }
          si (label_char == "u") { char_code = 117; }
          si (label_char == "v") { char_code = 118; }
          si (label_char == "w") { char_code = 119; }
          si (label_char == "x") { char_code = 120; }
          si (label_char == "y") { char_code = 121; }
          si (label_char == "z") { char_code = 122; }
          
          si (label_char == "A") { char_code = 65; }
          si (label_char == "B") { char_code = 66; }
          si (label_char == "C") { char_code = 67; }
          si (label_char == "D") { char_code = 68; }
          si (label_char == "E") { char_code = 69; }
          si (label_char == "F") { char_code = 70; }
          si (label_char == "G") { char_code = 71; }
          si (label_char == "H") { char_code = 72; }
          si (label_char == "I") { char_code = 73; }
          si (label_char == "J") { char_code = 74; }
          si (label_char == "K") { char_code = 75; }
          si (label_char == "L") { char_code = 76; }
          si (label_char == "M") { char_code = 77; }
          si (label_char == "N") { char_code = 78; }
          si (label_char == "O") { char_code = 79; }
          si (label_char == "P") { char_code = 80; }
          si (label_char == "Q") { char_code = 81; }
          si (label_char == "R") { char_code = 82; }
          si (label_char == "S") { char_code = 83; }
          si (label_char == "T") { char_code = 84; }
          si (label_char == "U") { char_code = 85; }
          si (label_char == "V") { char_code = 86; }
          si (label_char == "W") { char_code = 87; }
          si (label_char == "X") { char_code = 88; }
          si (label_char == "Y") { char_code = 89; }
          si (label_char == "Z") { char_code = 90; }
          
          si (label_char == "0") { char_code = 48; }
          si (label_char == "1") { char_code = 49; }
          si (label_char == "2") { char_code = 50; }
          si (label_char == "3") { char_code = 51; }
          si (label_char == "4") { char_code = 52; }
          si (label_char == "5") { char_code = 53; }
          si (label_char == "6") { char_code = 54; }
          si (label_char == "7") { char_code = 55; }
          si (label_char == "8") { char_code = 56; }
          si (label_char == "9") { char_code = 57; }
          si (label_char == "-") { char_code = 45; }
          
          encoded[label_start + 1 + i] = char_code;
          i = i + 1;
        }
      }
      
      encoded_idx = label_start + label_length + 1;
      encoded[encoded_idx] = 0;
      encoded_idx = encoded_idx + 1;
      done_encoding = 1;
    } sinon {
      si (ch == ".") {
        encoded[label_start] = label_length;
        
        variable i: entier = 0;
        variable copy_done: entier = 0;
        tantque (copy_done == 0) {
          si (i == label_length) {
            copy_done = 1;
          } sinon {
            variable label_char: chaine = domain[label_start + 1 + i];
            variable char_code: entier = 0;
            
            si (label_char == "a") { char_code = 97; }
            si (label_char == "b") { char_code = 98; }
            si (label_char == "c") { char_code = 99; }
            si (label_char == "d") { char_code = 100; }
            si (label_char == "e") { char_code = 101; }
            si (label_char == "f") { char_code = 102; }
            si (label_char == "g") { char_code = 103; }
            si (label_char == "h") { char_code = 104; }
            si (label_char == "i") { char_code = 105; }
            si (label_char == "j") { char_code = 106; }
            si (label_char == "k") { char_code = 107; }
            si (label_char == "l") { char_code = 108; }
            si (label_char == "m") { char_code = 109; }
            si (label_char == "n") { char_code = 110; }
            si (label_char == "o") { char_code = 111; }
            si (label_char == "p") { char_code = 112; }
            si (label_char == "q") { char_code = 113; }
            si (label_char == "r") { char_code = 114; }
            si (label_char == "s") { char_code = 115; }
            si (label_char == "t") { char_code = 116; }
            si (label_char == "u") { char_code = 117; }
            si (label_char == "v") { char_code = 118; }
            si (label_char == "w") { char_code = 119; }
            si (label_char == "x") { char_code = 120; }
            si (label_char == "y") { char_code = 121; }
            si (label_char == "z") { char_code = 122; }
            
            si (label_char == "A") { char_code = 65; }
            si (label_char == "B") { char_code = 66; }
            si (label_char == "C") { char_code = 67; }
            si (label_char == "D") { char_code = 68; }
            si (label_char == "E") { char_code = 69; }
            si (label_char == "F") { char_code = 70; }
            si (label_char == "G") { char_code = 71; }
            si (label_char == "H") { char_code = 72; }
            si (label_char == "I") { char_code = 73; }
            si (label_char == "J") { char_code = 74; }
            si (label_char == "K") { char_code = 75; }
            si (label_char == "L") { char_code = 76; }
            si (label_char == "M") { char_code = 77; }
            si (label_char == "N") { char_code = 78; }
            si (label_char == "O") { char_code = 79; }
            si (label_char == "P") { char_code = 80; }
            si (label_char == "Q") { char_code = 81; }
            si (label_char == "R") { char_code = 82; }
            si (label_char == "S") { char_code = 83; }
            si (label_char == "T") { char_code = 84; }
            si (label_char == "U") { char_code = 85; }
            si (label_char == "V") { char_code = 86; }
            si (label_char == "W") { char_code = 87; }
            si (label_char == "X") { char_code = 88; }
            si (label_char == "Y") { char_code = 89; }
            si (label_char == "Z") { char_code = 90; }
            
            si (label_char == "0") { char_code = 48; }
            si (label_char == "1") { char_code = 49; }
            si (label_char == "2") { char_code = 50; }
            si (label_char == "3") { char_code = 51; }
            si (label_char == "4") { char_code = 52; }
            si (label_char == "5") { char_code = 53; }
            si (label_char == "6") { char_code = 54; }
            si (label_char == "7") { char_code = 55; }
            si (label_char == "8") { char_code = 56; }
            si (label_char == "9") { char_code = 57; }
            si (label_char == "-") { char_code = 45; }
            
            encoded[label_start + 1 + i] = char_code;
            i = i + 1;
          }
        }
        
        encoded_idx = label_start + label_length + 1;
        label_start = encoded_idx;
        label_length = 0;
      } sinon {
        label_length = label_length + 1;
      }
      
      domain_idx = domain_idx + 1;
    }
  }
  
  retourner encoded;
}

fonction decode_dns_name(data: [512]entier, offset: entier) chaine {
  variable name: chaine = "";
  variable current_offset: entier = offset;
  variable jumped: entier = 0;
  variable jump_offset: entier = 0;
  variable max_depth: entier = 0;
  variable done_decoding: entier = 0;
  
  tantque (done_decoding == 0) {
    si (max_depth >= 10) {
      done_decoding = 1;
    } sinon {
      variable length: entier = data[current_offset];
      
      si (length == 0) {
        current_offset = current_offset + 1;
        done_decoding = 1;
      } sinon {
        si ((length / 64) == 3) {
          variable ptr_low: entier = data[current_offset + 1];
          variable ptr_high: entier = length % 64;
          variable pointer: entier = ptr_high * 256 + ptr_low;
          
          si (jumped == 0) {
            jump_offset = current_offset + 2;
          }
          
          current_offset = pointer;
          jumped = 1;
        } sinon {
          si (name.length > 0) {
            name = name + ".";
          }
          
          variable i: entier = 0;
          variable copy_done: entier = 0;
          tantque (copy_done == 0) {
            si (i == length) {
              copy_done = 1;
            } sinon {
              variable ch_int: entier = data[current_offset + 1 + i];
              name = name + ascii_to_char(ch_int);
              i = i + 1;
            }
          }
          
          current_offset = current_offset + length + 1;
          max_depth = max_depth + 1;
        }
      }
    }
  }
  
  retourner name;
}

// ==================== DNS PACKET PARSING ====================

fonction parse_dns_header(data: [512]entier, offset: entier) DNSHeader {
  variable header: DNSHeader = DNSHeader{
    id: 0, qr: 0, opcode: 0, aa: 0, tc: 0, rd: 0, 
    ra: 0, z: 0, rcode: 0, qdcount: 0, ancount: 0, 
    nscount: 0, arcount: 0
  };
  
  header.id = data[offset] * 256 + data[offset + 1];
  
  variable flags_byte1: entier = data[offset + 2];
  variable flags_byte2: entier = data[offset + 3];
  
  header.qr = flags_byte1 / 128;
  header.opcode = (flags_byte1 / 8) % 16;
  header.aa = (flags_byte1 / 4) % 2;
  header.tc = (flags_byte1 / 2) % 2;
  header.rd = flags_byte1 % 2;
  
  header.ra = flags_byte2 / 128;
  header.z = (flags_byte2 / 16) % 8;
  header.rcode = flags_byte2 % 16;
  
  header.qdcount = data[offset + 4] * 256 + data[offset + 5];
  header.ancount = data[offset + 6] * 256 + data[offset + 7];
  header.nscount = data[offset + 8] * 256 + data[offset + 9];
  header.arcount = data[offset + 10] * 256 + data[offset + 11];
  
  retourner header;
}

fonction parse_dns_question(data: [512]entier, offset: entier) DNSQuestion {
  variable question: DNSQuestion = DNSQuestion{
    name: "",
    type: 0,
    class: 0
  };
  
  question.name = decode_dns_name(data, offset);
  
  variable name_end: entier = offset;
  variable name_done: entier = 0;
  tantque (name_done == 0) {
    si (name_end >= 512) {
      name_done = 1;
    } sinon {
      si (data[name_end] == 0) {
        name_end = name_end + 1;
        name_done = 1;
      } sinon {
        si ((data[name_end] / 64) == 3) {
          name_end = name_end + 2;
          name_done = 1;
        } sinon {
          name_end = name_end + data[name_end] + 1;
        }
      }
    }
  }
  
  question.type = data[name_end] * 256 + data[name_end + 1];
  question.class = data[name_end + 2] * 256 + data[name_end + 3];
  
  retourner question;
}

fonction rdata_to_string(rr_type: entier, rdata: [512]entier, rdlength: entier) chaine {
  si (rr_type == DNS_TYPE_A) {
    si (rdlength >= 4) {
      retourner int_to_string(rdata[0]) + "." +
             int_to_string(rdata[1]) + "." +
             int_to_string(rdata[2]) + "." +
             int_to_string(rdata[3]);
    }
  }
  
  si (rr_type == DNS_TYPE_AAAA) {
    variable result: chaine = "";
    variable i: entier = 0;
    variable hex_done: entier = 0;
    tantque (hex_done == 0) {
      si (i >= rdlength || i >= 16) {
        hex_done = 1;
      } sinon {
        result = result + byte_to_hex(rdata[i]);
        si (i % 2 == 1 && i < 15) {
          result = result + ":";
        }
        i = i + 1;
      }
    }
    retourner result;
  }
  
  si (rr_type == DNS_TYPE_CNAME || rr_type == DNS_TYPE_NS || rr_type == DNS_TYPE_PTR) {
    retourner decode_dns_name(rdata, 0);
  }
  
  si (rr_type == DNS_TYPE_MX) {
    si (rdlength >= 2) {
      variable preference: entier = rdata[0] * 256 + rdata[1];
      variable exchange: chaine = decode_dns_name(rdata, 2);
      retourner int_to_string(preference) + " " + exchange;
    }
  }
  
  si (rr_type == DNS_TYPE_TXT) {
    variable result: chaine = "\"";
    variable i: entier = 0;
    variable txt_done: entier = 0;
    tantque (txt_done == 0) {
      si (i >= rdlength) {
        txt_done = 1;
      } sinon {
        variable ch_int: entier = rdata[i];
        si (ch_int >= 32 && ch_int <= 126) {
          result = result + ascii_to_char(ch_int);
        } sinon {
          result = result + ".";
        }
        i = i + 1;
      }
    }
    result = result + "\"";
    retourner result;
  }
  
  si (rr_type == DNS_TYPE_SOA) {
    si (rdlength >= 22) {
      variable mname: chaine = decode_dns_name(rdata, 0);
      variable rname: chaine = decode_dns_name(rdata, 0);
      
      variable soa_offset: entier = 0;
      variable find_mname: entier = 0;
      tantque (find_mname == 0) {
        si (soa_offset >= 512 || rdata[soa_offset] == 0) {
          find_mname = 1;
          soa_offset = soa_offset + 1;
        } sinon {
          soa_offset = soa_offset + rdata[soa_offset] + 1;
        }
      }
      
      variable find_rname: entier = 0;
      tantque (find_rname == 0) {
        si (soa_offset >= 512 || rdata[soa_offset] == 0) {
          find_rname = 1;
          soa_offset = soa_offset + 1;
        } sinon {
          soa_offset = soa_offset + rdata[soa_offset] + 1;
        }
      }
      
      variable serial: entier = rdata[soa_offset] * 16777216 +
                       rdata[soa_offset + 1] * 65536 +
                       rdata[soa_offset + 2] * 256 +
                       rdata[soa_offset + 3];
      variable refresh: entier = rdata[soa_offset + 4] * 16777216 +
                        rdata[soa_offset + 5] * 65536 +
                        rdata[soa_offset + 6] * 256 +
                        rdata[soa_offset + 7];
      variable retry: entier = rdata[soa_offset + 8] * 16777216 +
                      rdata[soa_offset + 9] * 65536 +
                      rdata[soa_offset + 10] * 256 +
                      rdata[soa_offset + 11];
      variable expire: entier = rdata[soa_offset + 12] * 16777216 +
                       rdata[soa_offset + 13] * 65536 +
                       rdata[soa_offset + 14] * 256 +
                       rdata[soa_offset + 15];
      variable minimum: entier = rdata[soa_offset + 16] * 16777216 +
                        rdata[soa_offset + 17] * 65536 +
                        rdata[soa_offset + 18] * 256 +
                        rdata[soa_offset + 19];
      
      retourner "MNAME=" + mname + " RNAME=" + rname +
             " SERIAL=" + int_to_string(serial) +
             " REFRESH=" + int_to_string(refresh) +
             " RETRY=" + int_to_string(retry) +
             " EXPIRE=" + int_to_string(expire) +
             " MINIMUM=" + int_to_string(minimum);
    }
  }
  
  variable result: chaine = "";
  variable i: entier = 0;
  variable hex_done: entier = 0;
  tantque (hex_done == 0) {
    si (i >= rdlength || i >= 20) {
      hex_done = 1;
    } sinon {
      result = result + byte_to_hex(rdata[i]);
      si (i < rdlength - 1 && i < 19) {
        result = result + " ";
      }
      i = i + 1;
    }
  }
  
  si (rdlength > 20) {
    result = result + "...";
  }
  
  retourner result;
}

fonction parse_dns_resource_record(data: [512]entier, offset: entier) DNSResourceRecord {
  variable rr: DNSResourceRecord = DNSResourceRecord{
    name: "",
    type: 0,
    class: 0,
    ttl: 0,
    rdlength: 0,
    rdata: [512]entier{0},
    rdata_str: ""
  };
  
  rr.name = decode_dns_name(data, offset);
  
  variable name_end: entier = offset;
  variable find_name_end: entier = 0;
  tantque (find_name_end == 0) {
    si (name_end >= 512) {
      find_name_end = 1;
    } sinon {
      si (data[name_end] == 0) {
        name_end = name_end + 1;
        find_name_end = 1;
      } sinon {
        si ((data[name_end] / 64) == 3) {
          name_end = name_end + 2;
          find_name_end = 1;
        } sinon {
          name_end = name_end + data[name_end] + 1;
        }
      }
    }
  }
  
  rr.type = data[name_end] * 256 + data[name_end + 1];
  rr.class = data[name_end + 2] * 256 + data[name_end + 3];
  rr.ttl = data[name_end + 4] * 16777216 +
           data[name_end + 5] * 65536 +
           data[name_end + 6] * 256 +
           data[name_end + 7];
  
  rr.rdlength = data[name_end + 8] * 256 + data[name_end + 9];
  
  variable rdata_start: entier = name_end + 10;
  variable i: entier = 0;
  variable copy_done: entier = 0;
  tantque (copy_done == 0) {
    si (i >= rr.rdlength || i >= 512) {
      copy_done = 1;
    } sinon {
      rr.rdata[i] = data[rdata_start + i];
      i = i + 1;
    }
  }
  
  rr.rdata_str = rdata_to_string(rr.type, rr.rdata, rr.rdlength);
  
  retourner rr;
}

fonction parse_dns_message(data: [512]entier, length: entier) DNSMessage {
  variable message: DNSMessage = DNSMessage{
    header: DNSHeader{id: 0, qr: 0, opcode: 0, aa: 0, tc: 0, rd: 0, ra: 0, z: 0, rcode: 0, 
                     qdcount: 0, ancount: 0, nscount: 0, arcount: 0},
    questions: [10]DNSQuestion{},
    answers: [20]DNSResourceRecord{},
    authorities: [10]DNSResourceRecord{},
    additionals: [10]DNSResourceRecord{},
    question_count: 0,
    answer_count: 0,
    authority_count: 0,
    additional_count: 0,
    raw_data: [512]entier{0},
    raw_length: length
  };
  
  variable i: entier = 0;
  variable copy_raw_done: entier = 0;
  tantque (copy_raw_done == 0) {
    si (i >= length || i >= 512) {
      copy_raw_done = 1;
    } sinon {
      message.raw_data[i] = data[i];
      i = i + 1;
    }
  }
  
  message.header = parse_dns_header(data, 0);
  
  variable offset: entier = 12;
  message.question_count = 0;
  variable parse_questions_done: entier = 0;
  
  tantque (parse_questions_done == 0) {
    si (message.question_count >= message.header.qdcount || 
        message.question_count >= 10) {
      parse_questions_done = 1;
    } sinon {
      message.questions[message.question_count] = parse_dns_question(data, offset);
      
      variable temp_offset: entier = offset;
      variable find_q_end: entier = 0;
      tantque (find_q_end == 0) {
        si (temp_offset >= 512) {
          find_q_end = 1;
        } sinon {
          si (data[temp_offset] == 0) {
            temp_offset = temp_offset + 1;
            find_q_end = 1;
          } sinon {
            si ((data[temp_offset] / 64) == 3) {
              temp_offset = temp_offset + 2;
              find_q_end = 1;
            } sinon {
              temp_offset = temp_offset + data[temp_offset] + 1;
            }
          }
        }
      }
      
      temp_offset = temp_offset + 4;
      
      offset = temp_offset;
      message.question_count = message.question_count + 1;
    }
  }
  
  message.answer_count = 0;
  variable parse_answers_done: entier = 0;
  
  tantque (parse_answers_done == 0) {
    si (message.answer_count >= message.header.ancount || 
        message.answer_count >= 20) {
      parse_answers_done = 1;
    } sinon {
      message.answers[message.answer_count] = parse_dns_resource_record(data, offset);
      
      variable temp_offset: entier = offset;
      variable find_rr_end: entier = 0;
      tantque (find_rr_end == 0) {
        si (temp_offset >= 512) {
          find_rr_end = 1;
        } sinon {
          si (data[temp_offset] == 0) {
            temp_offset = temp_offset + 1;
            find_rr_end = 1;
          } sinon {
            si ((data[temp_offset] / 64) == 3) {
              temp_offset = temp_offset + 2;
              find_rr_end = 1;
            } sinon {
              temp_offset = temp_offset + data[temp_offset] + 1;
            }
          }
        }
      }
      
      temp_offset = temp_offset + 10;
      
      variable rdlength: entier = message.answers[message.answer_count].rdlength;
      temp_offset = temp_offset + rdlength;
      
      offset = temp_offset;
      message.answer_count = message.answer_count + 1;
    }
  }
  
  message.authority_count = 0;
  variable parse_authorities_done: entier = 0;
  
  tantque (parse_authorities_done == 0) {
    si (message.authority_count >= message.header.nscount || 
        message.authority_count >= 10) {
      parse_authorities_done = 1;
    } sinon {
      message.authorities[message.authority_count] = parse_dns_resource_record(data, offset);
      
      variable temp_offset: entier = offset;
      variable find_auth_end: entier = 0;
      tantque (find_auth_end == 0) {
        si (temp_offset >= 512) {
          find_auth_end = 1;
        } sinon {
          si (data[temp_offset] == 0) {
            temp_offset = temp_offset + 1;
            find_auth_end = 1;
          } sinon {
            si ((data[temp_offset] / 64) == 3) {
              temp_offset = temp_offset + 2;
              find_auth_end = 1;
            } sinon {
              temp_offset = temp_offset + data[temp_offset] + 1;
            }
          }
        }
      }
      
      temp_offset = temp_offset + 10;
      
      variable rdlength: entier = message.authorities[message.authority_count].rdlength;
      temp_offset = temp_offset + rdlength;
      
      offset = temp_offset;
      message.authority_count = message.authority_count + 1;
    }
  }
  
  message.additional_count = 0;
  variable parse_additionals_done: entier = 0;
  
  tantque (parse_additionals_done == 0) {
    si (message.additional_count >= message.header.arcount || 
        message.additional_count >= 10) {
      parse_additionals_done = 1;
    } sinon {
      message.additionals[message.additional_count] = parse_dns_resource_record(data, offset);
      
      variable temp_offset: entier = offset;
      variable find_add_end: entier = 0;
      tantque (find_add_end == 0) {
        si (temp_offset >= 512) {
          find_add_end = 1;
        } sinon {
          si (data[temp_offset] == 0) {
            temp_offset = temp_offset + 1;
            find_add_end = 1;
          } sinon {
            si ((data[temp_offset] / 64) == 3) {
              temp_offset = temp_offset + 2;
              find_add_end = 1;
            } sinon {
              temp_offset = temp_offset + data[temp_offset] + 1;
            }
          }
        }
      }
      
      temp_offset = temp_offset + 10;
      
      variable rdlength: entier = message.additionals[message.additional_count].rdlength;
      temp_offset = temp_offset + rdlength;
      
      offset = temp_offset;
      message.additional_count = message.additional_count + 1;
    }
  }
  
  retourner message;
}

// ==================== DNS MESSAGE CREATION ====================

fonction create_dns_query(domain: chaine, qtype: entier, qclass: entier) [512]entier {
  variable packet: [512]entier = [512]entier{0};
  
  variable query_id: entier = 1000;
  packet[0] = query_id / 256;
  packet[1] = query_id % 256;
  query_id = query_id + 1;
  
  packet[2] = 1;
  packet[3] = 0;
  
  packet[4] = 0;
  packet[5] = 1;
  
  packet[6] = 0;
  packet[7] = 0;
  
  packet[8] = 0;
  packet[9] = 0;
  
  packet[10] = 0;
  packet[11] = 0;
  
  variable encoded_name: [256]entier = encode_dns_name(domain);
  variable name_idx: entier = 0;
  variable packet_idx: entier = 12;
  variable copy_name_done: entier = 0;
  
  tantque (copy_name_done == 0) {
    si (encoded_name[name_idx] == 0) {
      packet[packet_idx] = 0;
      packet_idx = packet_idx + 1;
      copy_name_done = 1;
    } sinon {
      packet[packet_idx] = encoded_name[name_idx];
      packet_idx = packet_idx + 1;
      name_idx = name_idx + 1;
    }
  }
  
  packet[packet_idx] = qtype / 256;
  packet[packet_idx + 1] = qtype % 256;
  
  packet[packet_idx + 2] = qclass / 256;
  packet[packet_idx + 3] = qclass % 256;
  
  retourner packet;
}

// ==================== DNS CACHE IMPLEMENTATION ====================

fonction create_dns_cache(max_entries: entier) DNSCache {
  variable cache: DNSCache = DNSCache{
    entries: [100]DNSCacheEntry{},
    entry_count: 0,
    max_entries: max_entries
  };
  
  variable i: entier = 0;
  variable init_done: entier = 0;
  tantque (init_done == 0) {
    si (i >= 100) {
      init_done = 1;
    } sinon {
      cache.entries[i] = DNSCacheEntry{
        name: "",
        type: 0,
        class: 0,
        ttl: 0,
        data: [512]entier{0},
        data_length: 0,
        timestamp: 0
      };
      i = i + 1;
    }
  }
  
  retourner cache;
}

fonction dns_cache_lookup(cache: DNSCache, name: chaine, qtype: entier, qclass: entier) DNSCacheEntry {
  variable empty_entry: DNSCacheEntry = DNSCacheEntry{
    name: "",
    type: 0,
    class: 0,
    ttl: 0,
    data: [512]entier{0},
    data_length: 0,
    timestamp: 0
  };
  
  variable i: entier = 0;
  variable lookup_done: entier = 0;
  
  tantque (lookup_done == 0) {
    si (i >= cache.entry_count) {
      lookup_done = 1;
    } sinon {
      variable entry: DNSCacheEntry = cache.entries[i];
      
      si (entry.name == name) {
        si (entry.type == qtype || qtype == 255) {
          si (entry.class == qclass || qclass == 255) {
            si (entry.timestamp + entry.ttl > 0) {
              retourner entry;
            }
          }
        }
      }
      
      i = i + 1;
    }
  }
  
  retourner empty_entry;
}

fonction dns_cache_store(cache: *DNSCache, name: chaine, type: entier, class: entier, 
                     ttl: entier, data: [512]entier, data_length: entier) entier {
  si (cache.entry_count >= cache.max_entries) {
    variable oldest_idx: entier = 0;
    variable oldest_time: entier = cache.entries[0].timestamp;
    variable i: entier = 1;
    variable find_oldest_done: entier = 0;
    
    tantque (find_oldest_done == 0) {
      si (i >= cache.entry_count) {
        find_oldest_done = 1;
      } sinon {
        si (cache.entries[i].timestamp < oldest_time) {
          oldest_time = cache.entries[i].timestamp;
          oldest_idx = i;
        }
        i = i + 1;
      }
    }
    
    cache.entries[oldest_idx] = DNSCacheEntry{
      name: name,
      type: type,
      class: class,
      ttl: ttl,
      data: data,
      data_length: data_length,
      timestamp: 0
    };
  } sinon {
    cache.entries[cache.entry_count] = DNSCacheEntry{
      name: name,
      type: type,
      class: class,
      ttl: ttl,
      data: data,
      data_length: data_length,
      timestamp: 0
    };
    cache.entry_count = cache.entry_count + 1;
  }
  
  retourner 0;
}

// ==================== DNS MESSAGE DISPLAY ====================

fonction print_dns_message(msg: DNSMessage) {
  afficher("");
  afficher("=== DNS MESSAGE ===");
  afficher("");
  
  afficher("HEADER:");
  afficher("  ID: ", msg.header.id);
  
  variable qr_str: chaine = "";
  si (msg.header.qr == 0) {
    qr_str = "Query";
  } sinon {
    qr_str = "Response";
  }
  afficher("  QR: ", msg.header.qr, " (", qr_str, ")");
  
  afficher("  Opcode: ", msg.header.opcode);
  
  variable aa_str: chaine = "";
  si (msg.header.aa == 0) {
    aa_str = "Non-authoritative";
  } sinon {
    aa_str = "Authoritative";
  }
  afficher("  AA: ", msg.header.aa, " (", aa_str, ")");
  
  variable tc_str: chaine = "";
  si (msg.header.tc == 0) {
    tc_str = "Not truncated";
  } sinon {
    tc_str = "Truncated";
  }
  afficher("  TC: ", msg.header.tc, " (", tc_str, ")");
  
  variable rd_str: chaine = "";
  si (msg.header.rd == 0) {
    rd_str = "No recursion";
  } sinon {
    rd_str = "Recursion desired";
  }
  afficher("  RD: ", msg.header.rd, " (", rd_str, ")");
  
  variable ra_str: chaine = "";
  si (msg.header.ra == 0) {
    ra_str = "No recursion";
  } sinon {
    ra_str = "Recursion available";
  }
  afficher("  RA: ", msg.header.ra, " (", ra_str, ")");
  
  afficher("  RCODE: ", msg.header.rcode, " (", get_rcode_name(msg.header.rcode), ")");
  
  afficher("  QDCOUNT: ", msg.header.qdcount);
  afficher("  ANCOUNT: ", msg.header.ancount);
  afficher("  NSCOUNT: ", msg.header.nscount);
  afficher("  ARCOUNT: ", msg.header.arcount);
  
  si (msg.question_count > 0) {
    afficher("");
    afficher("QUESTIONS (", msg.question_count, "):");
    
    variable i: entier = 0;
    variable print_q_done: entier = 0;
    
    tantque (print_q_done == 0) {
      si (i >= msg.question_count) {
        print_q_done = 1;
      } sinon {
        variable q: DNSQuestion = msg.questions[i];
        afficher("  ", i + 1, ". ", q.name);
        afficher("     Type: ", q.type, " (", get_rr_type_name(q.type), ")");
        afficher("     Class: ", q.class, " (", get_rr_class_name(q.class), ")");
        i = i + 1;
      }
    }
  }
  
  si (msg.answer_count > 0) {
    afficher("");
    afficher("ANSWERS (", msg.answer_count, "):");
    
    variable i: entier = 0;
    variable print_a_done: entier = 0;
    
    tantque (print_a_done == 0) {
      si (i >= msg.answer_count) {
        print_a_done = 1;
      } sinon {
        variable rr: DNSResourceRecord = msg.answers[i];
        afficher("  ", i + 1, ". ", rr.name);
        afficher("     Type: ", rr.type, " (", get_rr_type_name(rr.type), ")");
        afficher("     Class: ", rr.class, " (", get_rr_class_name(rr.class), ")");
        afficher("     TTL: ", rr.ttl, " seconds");
        afficher("     RDATA: ", rr.rdata_str);
        i = i + 1;
      }
    }
  }
  
  si (msg.authority_count > 0) {
    afficher("");
    afficher("AUTHORITY RECORDS (", msg.authority_count, "):");
    
    variable i: entier = 0;
    variable print_auth_done: entier = 0;
    
    tantque (print_auth_done == 0) {
      si (i >= msg.authority_count) {
        print_auth_done = 1;
      } sinon {
        variable rr: DNSResourceRecord = msg.authorities[i];
        afficher("  ", i + 1, ". ", rr.name);
        afficher("     Type: ", rr.type, " (", get_rr_type_name(rr.type), ")");
        afficher("     Class: ", rr.class, " (", get_rr_class_name(rr.class), ")");
        afficher("     TTL: ", rr.ttl, " seconds");
        afficher("     RDATA: ", rr.rdata_str);
        i = i + 1;
      }
    }
  }
  
  si (msg.additional_count > 0) {
    afficher("");
    afficher("ADDITIONAL RECORDS (", msg.additional_count, "):");
    
    variable i: entier = 0;
    variable print_add_done: entier = 0;
    
    tantque (print_add_done == 0) {
      si (i >= msg.additional_count) {
        print_add_done = 1;
      } sinon {
        variable rr: DNSResourceRecord = msg.additionals[i];
        afficher("  ", i + 1, ". ", rr.name);
        afficher("     Type: ", rr.type, " (", get_rr_type_name(rr.type), ")");
        afficher("     Class: ", rr.class, " (", get_rr_class_name(rr.class), ")");
        afficher("     TTL: ", rr.ttl, " seconds");
        afficher("     RDATA: ", rr.rdata_str);
        i = i + 1;
      }
    }
  }
  
  afficher("");
  afficher("RAW PACKET DATA (first 64 bytes):");
  variable hex_line: chaine = "  ";
  variable i: entier = 0;
  variable print_hex_done: entier = 0;
  
  tantque (print_hex_done == 0) {
    si (i >= 64 || i >= msg.raw_length) {
      print_hex_done = 1;
    } sinon {
      hex_line = hex_line + byte_to_hex(msg.raw_data[i]) + " ";
      si (i % 16 == 15) {
        afficher(hex_line);
        hex_line = "  ";
      }
      i = i + 1;
    }
  }
  
  si (hex_line != "  ") {
    afficher(hex_line);
  }
}

// ==================== DNS RESOLVER SIMULATION ====================

fonction simulate_dns_query(domain: chaine, qtype: entier, qclass: entier) DNSMessage {
  variable query_packet: [512]entier = create_dns_query(domain, qtype, qclass);
  
  variable response_data: [512]entier = [512]entier{0};
  
  si (domain == "example.com" && qtype == DNS_TYPE_A) {
    response_data[0] = 0; response_data[1] = 100;
    response_data[2] = 129;
    response_data[3] = 128;
    response_data[4] = 0; response_data[5] = 1;
    response_data[6] = 0; response_data[7] = 1;
    response_data[8] = 0; response_data[9] = 0;
    response_data[10] = 0; response_data[11] = 0;
    
    response_data[12] = 7;
    response_data[13] = 101;
    response_data[14] = 120;
    response_data[15] = 97;
    response_data[16] = 109;
    response_data[17] = 112;
    response_data[18] = 108;
    response_data[19] = 101;
    response_data[20] = 3;
    response_data[21] = 99;
    response_data[22] = 111;
    response_data[23] = 109;
    response_data[24] = 0;
    response_data[25] = 0; response_data[26] = 1;
    response_data[27] = 0; response_data[28] = 1;
    
    response_data[29] = 192;
    response_data[30] = 12;
    
    response_data[31] = 0; response_data[32] = 1;
    response_data[33] = 0; response_data[34] = 1;
    response_data[35] = 0; response_data[36] = 0;
    response_data[37] = 0; response_data[38] = 300;
    response_data[39] = 0; response_data[40] = 4;
    
    response_data[41] = 93;
    response_data[42] = 184;
    response_data[43] = 216;
    response_data[44] = 34;
    
    retourner parse_dns_message(response_data, 45);
  } sinon {
    si (domain == "google.com" && qtype == DNS_TYPE_A) {
      response_data[0] = 0; response_data[1] = 101;
      response_data[2] = 129;
      response_data[3] = 128;
      response_data[4] = 0; response_data[5] = 1;
      response_data[6] = 0; response_data[7] = 1;
      response_data[8] = 0; response_data[9] = 0;
      response_data[10] = 0; response_data[11] = 0;
      
      response_data[12] = 6;
      response_data[13] = 103;
      response_data[14] = 111;
      response_data[15] = 111;
      response_data[16] = 103;
      response_data[17] = 108;
      response_data[18] = 101;
      response_data[19] = 3;
      response_data[20] = 99;
      response_data[21] = 111;
      response_data[22] = 109;
      response_data[23] = 0;
      response_data[24] = 0; response_data[25] = 1;
      response_data[26] = 0; response_data[27] = 1;
      
      response_data[28] = 192;
      response_data[29] = 12;
      
      response_data[30] = 0; response_data[31] = 1;
      response_data[32] = 0; response_data[33] = 1;
      response_data[34] = 0; response_data[35] = 0;
      response_data[36] = 0; response_data[37] = 300;
      response_data[38] = 0; response_data[39] = 4;
      
      response_data[40] = 142;
      response_data[41] = 250;
      response_data[42] = 185;
      response_data[43] = 78;
      
      retourner parse_dns_message(response_data, 44);
    } sinon {
      si (domain == "example.com" && qtype == DNS_TYPE_NS) {
        response_data[0] = 0; response_data[1] = 102;
        response_data[2] = 129;
        response_data[3] = 128;
        response_data[4] = 0; response_data[5] = 1;
        response_data[6] = 0; response_data[7] = 2;
        response_data[8] = 0; response_data[9] = 0;
        response_data[10] = 0; response_data[11] = 0;
        
        response_data[12] = 7;
        response_data[13] = 101;
        response_data[14] = 120;
        response_data[15] = 97;
        response_data[16] = 109;
        response_data[17] = 112;
        response_data[18] = 108;
        response_data[19] = 101;
        response_data[20] = 3;
        response_data[21] = 99;
        response_data[22] = 111;
        response_data[23] = 109;
        response_data[24] = 0;
        response_data[25] = 0; response_data[26] = 2;
        response_data[27] = 0; response_data[28] = 1;
        
        response_data[29] = 192;
        response_data[30] = 12;
        
        response_data[31] = 0; response_data[32] = 2;
        response_data[33] = 0; response_data[34] = 1;
        response_data[35] = 0; response_data[36] = 0;
        response_data[37] = 0; response_data[38] = 86400;
        response_data[39] = 0; response_data[40] = 15;
        
        response_data[41] = 3;
        response_data[42] = 110;
        response_data[43] = 115;
        response_data[44] = 49;
        response_data[45] = 192;
        response_data[46] = 12;
        
        response_data[47] = 192;
        response_data[48] = 12;
        
        response_data[49] = 0; response_data[50] = 2;
        response_data[51] = 0; response_data[52] = 1;
        response_data[53] = 0; response_data[54] = 0;
        response_data[55] = 0; response_data[56] = 86400;
        response_data[57] = 0; response_data[58] = 15;
        
        response_data[59] = 3;
        response_data[60] = 110;
        response_data[61] = 115;
        response_data[62] = 50;
        response_data[63] = 192;
        response_data[64] = 12;
        
        retourner parse_dns_message(response_data, 65);
      }
    }
  }
  
  variable empty_response: DNSMessage = DNSMessage{
    header: DNSHeader{id: 0, qr: 1, opcode: 0, aa: 0, tc: 0, rd: 0, 
                     ra: 0, z: 0, rcode: DNS_RCODE_NXDOMAIN, 
                     qdcount: 0, ancount: 0, nscount: 0, arcount: 0},
    questions: [10]DNSQuestion{},
    answers: [20]DNSResourceRecord{},
    authorities: [10]DNSResourceRecord{},
    additionals: [10]DNSResourceRecord{},
    question_count: 0,
    answer_count: 0,
    authority_count: 0,
    additional_count: 0,
    raw_data: [512]entier{0},
    raw_length: 12
  };
  
  retourner empty_response;
}

// ==================== MAIN TEST PROGRAM ====================

demarrer() entier {
  afficher("=========================================");
  afficher("FULLY-FEATURED DNS PARSER IMPLEMENTATION");
  afficher("=========================================");
  
  afficher("");
  afficher("TEST 1: DNS NAME ENCODING/DECODING");
  afficher("-----------------------------------");
  
  variable test_domain: chaine = "www.example.com";
  variable encoded: [256]entier = encode_dns_name(test_domain);
  variable decoded: chaine = decode_dns_name(encoded, 0);
  
  afficher("Original domain: ", test_domain);
  afficher("Encoded bytes: ", encoded[0], " ", encoded[1], " ", encoded[2], " ", 
        encoded[3], " ", encoded[4], " ", encoded[5], " ", encoded[6], " ", 
        encoded[7], " ", encoded[8], " ", encoded[9], " ", encoded[10], " ",
        encoded[11], " ", encoded[12], " ", encoded[13], " ", encoded[14], " ",
        encoded[15], " ", encoded[16]);
  afficher("Decoded domain: ", decoded);
  
  afficher("");
  afficher("TEST 2: CREATE DNS QUERY");
  afficher("-------------------------");
  
  variable query_packet: [512]entier = create_dns_query("example.com", DNS_TYPE_A, DNS_CLASS_IN);
  afficher("Query packet created (ID: ", query_packet[0] * 256 + query_packet[1], ")");
  afficher("Query type: A (", DNS_TYPE_A, ")");
  afficher("Query class: IN (", DNS_CLASS_IN, ")");
  
  afficher("");
  afficher("TEST 3: SIMULATE DNS QUERIES");
  afficher("----------------------------");
  
  afficher("");
  afficher("Query 1: example.com A record");
  variable response1: DNSMessage = simulate_dns_query("example.com", DNS_TYPE_A, DNS_CLASS_IN);
  print_dns_message(response1);
  
  afficher("");
  afficher("Query 2: google.com A record");
  variable response2: DNSMessage = simulate_dns_query("google.com", DNS_TYPE_A, DNS_CLASS_IN);
  print_dns_message(response2);
  
  afficher("");
  afficher("Query 3: example.com NS records");
  variable response3: DNSMessage = simulate_dns_query("example.com", DNS_TYPE_NS, DNS_CLASS_IN);
  print_dns_message(response3);
  
  afficher("");
  afficher("TEST 4: DNS CACHE");
  afficher("------------------");
  
  variable cache: DNSCache = create_dns_cache(10);
  afficher("DNS cache created with capacity: ", cache.max_entries);
  
  variable cache_data: [512]entier = [512]entier{0};
  cache_data[0] = 93;
  cache_data[1] = 184;
  cache_data[2] = 216;
  cache_data[3] = 34;
  
  dns_cache_store(cache, "example.com", DNS_TYPE_A, DNS_CLASS_IN, 300, cache_data, 4);
  afficher("Cached example.com A record");
  
  variable cached_entry: DNSCacheEntry = dns_cache_lookup(cache, "example.com", DNS_TYPE_A, DNS_CLASS_IN);
  si (cached_entry.name != "") {
    afficher("Cache hit for example.com");
    afficher("Cached IP: ", cached_entry.data[0], ".", cached_entry.data[1], ".",
          cached_entry.data[2], ".", cached_entry.data[3]);
  } sinon {
    afficher("Cache miss for example.com");
  }
  
  afficher("");
  afficher("TEST 5: ERROR HANDLING");
  afficher("----------------------");
  
  variable error_response: DNSMessage = simulate_dns_query("nonexistent.example", DNS_TYPE_A, DNS_CLASS_IN);
  afficher("Query for non-existent domain");
  afficher("Response RCODE: ", error_response.header.rcode, " (", 
        get_rcode_name(error_response.header.rcode), ")");
  
  afficher("");
  afficher("TEST 6: UTILITY FUNCTIONS");
  afficher("-------------------------");
  
  variable test_num: entier = 12345;
  variable num_str: chaine = int_to_string(test_num);
  variable str_num: entier = string_to_int(num_str);
  afficher("Number conversion test: ", test_num, " -> \"", num_str, "\" -> ", str_num);
  
  variable test_byte: entier = 255;
  variable hex_str: chaine = byte_to_hex(test_byte);
  afficher("Byte to hex: ", test_byte, " -> ", hex_str);
  
  afficher("");
  afficher("=========================================");
  afficher("DNS PARSER IMPLEMENTATION COMPLETE");
  afficher("=========================================");
  afficher("");
  afficher("Features implemented:");
  afficher("1. DNS packet parsing (header, questions, answers, authorities, additionals)");
  afficher("2. DNS name encoding/decoding with compression support");
  afficher("3. All major DNS record types (A, NS, CNAME, SOA, PTR, MX, TXT, AAAA, SRV)");
  afficher("4. DNS cache with TTL support");
  afficher("5. Query creation and response simulation");
  afficher("6. Complete erreur handling and RCODE support");
  afficher("7. Raw packet hex display");
  afficher("8. No break statements - all loops use condition variables");
  
  retourner 0;
}
