dialect:english;

// ==================== KAFKA PROTOCOL CONSTANTS AND STRUCTURES ====================

// API Keys (simplified)
let API_KEY_PRODUCE: int = 0;
let API_KEY_FETCH: int = 1;
let API_KEY_METADATA: int = 2;
let API_KEY_HEARTBEAT: int = 3;
let API_KEY_JOIN_GROUP: int = 4;
let API_KEY_SYNC_GROUP: int = 5;
let API_KEY_LEAVE_GROUP: int = 6;

// Error Codes
let ERROR_NONE: int = 0;
let ERROR_UNKNOWN: int = -1;
let ERROR_OFFSET_OUT_OF_RANGE: int = 1;
let ERROR_CORRUPT_MESSAGE: int = 2;
let ERROR_UNKNOWN_TOPIC_OR_PARTITION: int = 3;
let ERROR_INVALID_FETCH_SIZE: int = 4;
let ERROR_LEADER_NOT_AVAILABLE: int = 5;
let ERROR_NOT_LEADER_FOR_PARTITION: int = 6;
let ERROR_REQUEST_TIMED_OUT: int = 7;
let ERROR_BROKER_NOT_AVAILABLE: int = 8;
let ERROR_REPLICA_NOT_AVAILABLE: int = 9;
let ERROR_MESSAGE_TOO_LARGE: int = 10;
let ERROR_INVALID_CONFIG: int = 17;
let ERROR_NOT_COORDINATOR: int = 16;

// Compression Types
let COMPRESSION_NONE: int = 0;
let COMPRESSION_GZIP: int = 1;
let COMPRESSION_SNAPPY: int = 2;
let COMPRESSION_LZ4: int = 3;

// Message Flags
let MESSAGE_FLAG_NONE: int = 0;
let MESSAGE_FLAG_COMPRESSED: int = 1;

// Offsets
let OFFSET_EARLIEST: int = -2;
let OFFSET_LATEST: int = -1;

// Message Structure
struct Message {
  offset: int,
  timestamp: int,
  key: [1024]int,
  key_length: int,
  value: [8192]int,
  value_length: int,
  compression: int,
  checksum: int,
  partition: int,
}

struct MessageBatch {
  messages: [100]Message,
  message_count: int,
  base_offset: int,
  partition_leader_epoch: int,
  magic: int,
  compression_type: int,
  timestamp_type: int,
  max_timestamp: int,
  producer_id: int,
  producer_epoch: int,
  base_sequence: int,
}

struct TopicPartition {
  topic: string,
  partition: int,
  offset: int,
  leader_id: int,
}

struct Record {
  topic: string,
  partition: int,
  offset: int,
  timestamp: int,
  key: string,
  value: string,
}

// Kafka Request/Response Headers
struct KafkaHeader {
  api_key: int,
  api_version: int,
  correlation_id: int,
  client_id: string,
}

struct KafkaRequest {
  header: KafkaHeader,
  data: [65536]int,  // 64KB max request size
  length: int,
}

struct KafkaResponse {
  header: KafkaHeader,
  data: [65536]int,  // 64KB max response size
  length: int,
  error_code: int,
}

// Broker and Cluster Management
struct Broker {
  id: int,
  host: string,
  port: int,
  rack: string,
  is_alive: int,
}

struct PartitionMetadata {
  partition: int,
  leader: int,
  replicas: [10]int,
  replica_count: int,
  isr: [10]int,
  isr_count: int,
  error_code: int,
}

struct TopicMetadata {
  topic: string,
  partitions: [100]PartitionMetadata,
  partition_count: int,
  error_code: int,
}

struct ClusterMetadata {
  brokers: [100]Broker,
  broker_count: int,
  topics: [100]TopicMetadata,
  topic_count: int,
  controller_id: int,
}

// Consumer Group
struct ConsumerGroup {
  group_id: string,
  members: [100]ConsumerMember,
  member_count: int,
  protocol: string,
  leader_id: string,
  state: int,  // 0=Stable, 1=PreparingRebalance, 2=AwaitingSync, 3=Dead
}

struct ConsumerMember {
  member_id: string,
  client_id: string,
  client_host: string,
  partitions: [100]TopicPartition,
  partition_count: int,
}

// Producer State
struct ProducerState {
  producer_id: int,
  producer_epoch: int,
  sequence_numbers: [100]int,
  sequence_count: int,
}

// ==================== UTILITY FUNCTIONS ====================

func int_to_string(num: int) string {
  if (num == 0) {
    return "0";
  }
  
  let result: string = "";
  let temp: int = num;
  let is_negative: int = 0;
  
  if (temp < 0) {
    is_negative = 1;
    temp = 0 - temp;
  }
  
  let done: int = 0;
  while (done == 0) {
    if (temp == 0) {
      done = 1;
    } else {
      let digit: int = temp % 10;
      let digit_str: string = "";
      if (digit == 0) { digit_str = "0"; }
      if (digit == 1) { digit_str = "1"; }
      if (digit == 2) { digit_str = "2"; }
      if (digit == 3) { digit_str = "3"; }
      if (digit == 4) { digit_str = "4"; }
      if (digit == 5) { digit_str = "5"; }
      if (digit == 6) { digit_str = "6"; }
      if (digit == 7) { digit_str = "7"; }
      if (digit == 8) { digit_str = "8"; }
      if (digit == 9) { digit_str = "9"; }
      
      result = digit_str + result;
      temp = temp / 10;
    }
  }
  
  if (is_negative == 1) {
    result = "-" + result;
  }
  
  return result;
}

func string_to_int(str: string) int {
  let result: int = 0;
  let i: int = 0;
  let is_negative: int = 0;
  
  if (str.length > 0) {
    if (str[0] == "-") {
      is_negative = 1;
      i = 1;
    }
  }
  
  while (i < str.length) {
    let ch: string = str[i];
    let digit: int = 0;
    
    if (ch == "0") { digit = 0; }
    if (ch == "1") { digit = 1; }
    if (ch == "2") { digit = 2; }
    if (ch == "3") { digit = 3; }
    if (ch == "4") { digit = 4; }
    if (ch == "5") { digit = 5; }
    if (ch == "6") { digit = 6; }
    if (ch == "7") { digit = 7; }
    if (ch == "8") { digit = 8; }
    if (ch == "9") { digit = 9; }
    
    result = result * 10 + digit;
    i = i + 1;
  }
  
  if (is_negative == 1) {
    result = 0 - result;
  }
  
  return result;
}

func ascii_to_char(code: int) string {
  if (code == 32){ return " ";}
  if (code == 33){ return "!";}
  if (code == 34){ return "sq";}
  if (code == 35){ return "#";}
  if (code == 36){ return "$";}
  if (code == 37){ return "%";}
  if (code == 38){ return "&";}
  if (code == 39){ return "'";}
  if (code == 40){ return "(";}
  if (code == 41){ return ")";}
  if (code == 42){ return "*";}
  if (code == 43){ return "+";}
  if (code == 44){ return ",";}
  if (code == 45){ return "-";}
  if (code == 46){ return ".";}
  if (code == 47){ return "/";}
  if (code == 58){ return ":";}
  if (code == 59){ return ";";}
  if (code == 60){ return "<";}
  if (code == 61){ return "=";}
  if (code == 62){ return ">";}
  if (code == 63){ return "?";}
  if (code == 64){ return "@";}
  if (code == 91){ return "[";}
  if (code == 92){ return "\\";}
  if (code == 93){ return "]";}
  if (code == 94){ return "^";}
  if (code == 95){ return "_";}
  if (code == 96){ return "`";}
  if (code == 123){ return "{";}
  if (code == 124){ return "|";}
  if (code == 125){ return "}";}
  if (code == 126){ return "~";}
  
  if (code >= 48 && code <= 57) {
    return int_to_string(code - 48);
  }
  
  if (code >= 65 && code <= 90) {
    let letter_num: int = code - 65;
    if (letter_num == 0) { return "A";}
    if (letter_num == 1) { return "B";}
    if (letter_num == 2) { return "C";}
    if (letter_num == 3) { return "D";}
    if (letter_num == 4) { return "E";}
    if (letter_num == 5) { return "F";}
    if (letter_num == 6) { return "G";}
    if (letter_num == 7) { return "H";}
    if (letter_num == 8) { return "I";}
    if (letter_num == 9) { return "J";}
    if (letter_num == 10){ return "K";}
    if (letter_num == 11){ return "L";}
    if (letter_num == 12){ return "M";}
    if (letter_num == 13){ return "N";}
    if (letter_num == 14){ return "O";}
    if (letter_num == 15){ return "P";}
    if (letter_num == 16){ return "Q";}
    if (letter_num == 17){ return "R";}
    if (letter_num == 18){ return "S";}
    if (letter_num == 19){ return "T";}
    if (letter_num == 20){ return "U";}
    if (letter_num == 21){ return "V";}
    if (letter_num == 22){ return "W";}
    if (letter_num == 23){ return "X";}
    if (letter_num == 24){ return "Y";}
    return "Z";
  }
  
  if (code >= 97 && code <= 122) {
    let letter_num: int = code - 97;
    if (letter_num == 0)  { return "a";}
    if (letter_num == 1)  { return "b";}
    if (letter_num == 2)  { return "c";}
    if (letter_num == 3)  { return "d";}
    if (letter_num == 4)  { return "e";}
    if (letter_num == 5)  { return "f";}
    if (letter_num == 6)  { return "g";}
    if (letter_num == 7)  { return "h";}
    if (letter_num == 8)  { return "i";}
    if (letter_num == 9)  { return "j";}
    if (letter_num == 10) { return "k";}
    if (letter_num == 11) { return "l";}
    if (letter_num == 12) { return "m";}
    if (letter_num == 13) { return "n";}
    if (letter_num == 14) { return "o";}
    if (letter_num == 15) { return "p";}
    if (letter_num == 16) { return "q";}
    if (letter_num == 17) { return "r";}
    if (letter_num == 18) { return "s";}
    if (letter_num == 19) { return "t";}
    if (letter_num == 20) { return "u";}
    if (letter_num == 21) { return "v";}
    if (letter_num == 22) { return "w";}
    if (letter_num == 23) { return "x";}
    if (letter_num == 24) { return "y";}
    return "z";
  }
  
  return "?";
}

func char_to_ascii(ch: string) int {
  if (ch == " ") { return 32;}
  if (ch == "!") { return 33;}
  if (ch == "sq"){ return 34;}
  if (ch == "#") { return 35;}
  if (ch == "$") { return 36;}
  if (ch == "%") { return 37;}
  if (ch == "&") { return 38;}
  if (ch == "'") { return 39;}
  if (ch == "(") { return 40;}
  if (ch == ")") { return 41;}
  if (ch == "*") { return 42;}
  if (ch == "+") { return 43;}
  if (ch == ",") { return 44;}
  if (ch == "-") { return 45;}
  if (ch == ".") { return 46;}
  if (ch == "/") { return 47;}
  if (ch == ":") { return 58;}
  if (ch == ";") { return 59;}
  if (ch == "<") { return 60;}
  if (ch == "=") { return 61;}
  if (ch == ">") { return 62;}
  if (ch == "?") { return 63;}
  if (ch == "@") { return 64;}
  if (ch == "[") { return 91;}
  if (ch == "\\"){ return 92;}
  if (ch == "]") { return 93;}
  if (ch == "^") { return 94;}
  if (ch == "_") { return 95;}
  if (ch == "`") { return 96;}
  if (ch == "{") { return 123;}
  if (ch == "|") { return 124;}
  if (ch == "}") { return 125;}
  if (ch == "~") { return 126;}
  if (ch == "0") { return 48;}
  if (ch == "1") { return 49;}
  if (ch == "2") { return 50;}
  if (ch == "3") { return 51;}
  if (ch == "4") { return 52;}
  if (ch == "5") { return 53;}
  if (ch == "6") { return 54;}
  if (ch == "7") { return 55;}
  if (ch == "8") { return 56;}
  if (ch == "9") { return 57;}
  if (ch == "A"){ return 65;}
  if (ch == "B"){ return 66;}
  if (ch == "C"){ return 67;}
  if (ch == "D"){ return 68;}
  if (ch == "E"){ return 69;}
  if (ch == "F"){ return 70;}
  if (ch == "G"){ return 71;}
  if (ch == "H"){ return 72;}
  if (ch == "I"){ return 73;}
  if (ch == "J"){ return 74;}
  if (ch == "K"){ return 75;}
  if (ch == "L"){ return 76;}
  if (ch == "M"){ return 77;}
  if (ch == "N"){ return 78;}
  if (ch == "O"){ return 79;}
  if (ch == "P"){ return 80;}
  if (ch == "Q"){ return 81;}
  if (ch == "R"){ return 82;}
  if (ch == "S"){ return 83;}
  if (ch == "T"){ return 84;}
  if (ch == "U"){ return 85;}
  if (ch == "V"){ return 86;}
  if (ch == "W"){ return 87;}
  if (ch == "X"){ return 88;}
  if (ch == "Y"){ return 89;}
  if (ch == "Z"){ return 90;}
  if (ch == "a"){ return 97;}
  if (ch == "b"){ return 98;}
  if (ch == "c"){ return 99;}
  if (ch == "d"){ return 100;}
  if (ch == "e"){ return 101;}
  if (ch == "f"){ return 102;}
  if (ch == "g"){ return 103;}
  if (ch == "h"){ return 104;}
  if (ch == "i"){ return 105;}
  if (ch == "j"){ return 106;}
  if (ch == "k"){ return 107;}
  if (ch == "l"){ return 108;}
  if (ch == "m"){ return 109;}
  if (ch == "n"){ return 110;}
  if (ch == "o"){ return 111;}
  if (ch == "p"){ return 112;}
  if (ch == "q"){ return 113;}
  if (ch == "r"){ return 114;}
  if (ch == "s"){ return 115;}
  if (ch == "t"){ return 116;}
  if (ch == "u"){ return 117;}
  if (ch == "v"){ return 118;}
  if (ch == "w"){ return 119;}
  if (ch == "x"){ return 120;}
  if (ch == "y"){ return 121;}
  if (ch == "z"){ return 122;}
  
  return 63; // "?"
}

func string_to_ascii_array(str: string) [8192]int {
  let result: [8192]int = [8192]int{0};
  let i: int = 0;
  let done: int = 0;
  
  while (done == 0) {
    if (i >= str.length || i >= 8192) {
      done = 1;
    } else {
      result[i] = char_to_ascii(str[i]);
      i = i + 1;
    }
  }
  
  return result;
}

func ascii_array_to_string(data: [8192]int, length: int) string {
  let result: string = "";
  let i: int = 0;
  let done: int = 0;
  
  while (done == 0) {
    if (i >= length || i >= 8192) {
      done = 1;
    } else {
      result = result + ascii_to_char(data[i]);
      i = i + 1;
    }
  }
  
  return result;
}

func get_error_name(error_code: int) string {
  if (error_code == ERROR_NONE)                      { return "NONE";}
  if (error_code == ERROR_UNKNOWN)                   { return "UNKNOWN";}
  if (error_code == ERROR_OFFSET_OUT_OF_RANGE)       { return "OFFSET_OUT_OF_RANGE";}
  if (error_code == ERROR_CORRUPT_MESSAGE)           { return "CORRUPT_MESSAGE";}
  if (error_code == ERROR_UNKNOWN_TOPIC_OR_PARTITION){ return "UNKNOWN_TOPIC_OR_PARTITION";}
  if (error_code == ERROR_INVALID_FETCH_SIZE)        { return "INVALID_FETCH_SIZE";}
  if (error_code == ERROR_LEADER_NOT_AVAILABLE)      { return "LEADER_NOT_AVAILABLE";}
  if (error_code == ERROR_NOT_LEADER_FOR_PARTITION)  { return "NOT_LEADER_FOR_PARTITION";}
  if (error_code == ERROR_REQUEST_TIMED_OUT)         { return "REQUEST_TIMED_OUT";}
  if (error_code == ERROR_BROKER_NOT_AVAILABLE)      { return "BROKER_NOT_AVAILABLE";}
  if (error_code == ERROR_REPLICA_NOT_AVAILABLE)     { return "REPLICA_NOT_AVAILABLE";}
  if (error_code == ERROR_MESSAGE_TOO_LARGE)         { return "MESSAGE_TOO_LARGE";}
  if (error_code == ERROR_INVALID_CONFIG)            { return "INVALID_CONFIG";}
  if (error_code == ERROR_NOT_COORDINATOR)           { return "NOT_COORDINATOR";}
  return "UNKNOWN_ERROR_" + int_to_string(error_code);
}

func simple_checksum(data: [8192]int, length: int) int {
  let sum: int = 0;
  let i: int = 0;
  let done: int = 0;
  
  while (done == 0) {
    if (i >= length) {
      done = 1;
    } else {
      sum = sum + data[i];
      i = i + 1;
    }
  }
  
  // Simple modulo to keep in range
  while (sum > 65535) {
    sum = sum - 65536;
  }
  
  return sum;
}

// ==================== KAFKA WIRE PROTOCOL ====================

func encode_kafka_header(api_key: int, api_version: int, correlation_id: int, client_id: string) [1024]int {
  let header: [1024]int = [1024]int{0};
  let idx: int = 0;
  
  // API Key (int16)
  header[idx] = api_key / 256;
  header[idx + 1] = api_key % 256;
  idx = idx + 2;
  
  // API Version (int16)
  header[idx] = api_version / 256;
  header[idx + 1] = api_version % 256;
  idx = idx + 2;
  
  // Correlation ID (int32)
  header[idx] = correlation_id / 16777216;
  header[idx + 1] = (correlation_id / 65536) % 256;
  header[idx + 2] = (correlation_id / 256) % 256;
  header[idx + 3] = correlation_id % 256;
  idx = idx + 4;
  
  // Client ID (string)
  let client_id_len: int = client_id.length;
  header[idx] = client_id_len / 256;
  header[idx + 1] = client_id_len % 256;
  idx = idx + 2;
  
  let i: int = 0;
  let copy_client_done: int = 0;
  while (copy_client_done == 0) {
    if (i >= client_id_len) {
      copy_client_done = 1;
    } else {
      header[idx] = char_to_ascii(client_id[i]);
      idx = idx + 1;
      i = i + 1;
    }
  }
  
  return header;
}

func decode_kafka_header(data: [65536]int, offset: int) KafkaHeader {
  let header: KafkaHeader = KafkaHeader{
    api_key: 0,
    api_version: 0,
    correlation_id: 0,
    client_id: "",
  };
  
  // API Key
  header.api_key = data[offset] * 256 + data[offset + 1];
  
  // API Version
  header.api_version = data[offset + 2] * 256 + data[offset + 3];
  
  // Correlation ID
  header.correlation_id = data[offset + 4] * 16777216 +
                         data[offset + 5] * 65536 +
                         data[offset + 6] * 256 +
                         data[offset + 7];
  
  // Client ID length
  let client_id_len: int = data[offset + 8] * 256 + data[offset + 9];
  
  // Client ID
  let client_id_start: int = offset + 10;
  let i: int = 0;
  let build_client_done: int = 0;
  
  while (build_client_done == 0) {
    if (i >= client_id_len) {
      build_client_done = 1;
    } else {
      header.client_id = header.client_id + ascii_to_char(data[client_id_start + i]);
      i = i + 1;
    }
  }
  
  return header;
}

func encode_produce_request(topics: [10]string, topic_count: int, 
                           partitions: [10]int, partition_count: int,
                           messages: [100]Message, message_count: int,
                           correlation_id: int, client_id: string) KafkaRequest {
  let request: KafkaRequest = KafkaRequest{
    header: KafkaHeader{api_key: 0, api_version: 0, correlation_id: 0, client_id: ""},
    data: [65536]int{0},
    length: 0,
  };
  
  // Encode header
  let header_data: [1024]int = encode_kafka_header(API_KEY_PRODUCE, 2, correlation_id, client_id);
  
  // Copy header to request
  let idx: int = 0;
  let copy_header_done: int = 0;
  while (copy_header_done == 0) {
    if (idx >= 1024 || header_data[idx] == 0) {
      copy_header_done = 1;
    } else {
      request.data[idx] = header_data[idx];
      idx = idx + 1;
    }
  }
  
  request.length = idx;
  
  // Transactional ID (null for now)
  request.data[request.length] = 255;
  request.data[request.length + 1] = 255;
  request.length = request.length + 2;
  
  // ACKS (1 = leader only)
  request.data[request.length] = 1;
  request.length = request.length + 2;
  
  // Timeout (30000 ms)
  request.data[request.length] = 0;
  request.data[request.length + 1] = 0;
  request.data[request.length + 2] = 117;
  request.data[request.length + 3] = 48;
  request.length = request.length + 4;
  
  // Topic array count
  request.data[request.length] = 0;
  request.data[request.length + 1] = topic_count;
  request.length = request.length + 2;
  
  // Encode each topic
  let topic_idx: int = 0;
  let encode_topics_done: int = 0;
  while (encode_topics_done == 0) {
    if (topic_idx >= topic_count) {
      encode_topics_done = 1;
    } else {
      let topic: string = topics[topic_idx];
      
      // Topic name length
      let topic_len: int = topic.length;
      request.data[request.length] = topic_len / 256;
      request.data[request.length + 1] = topic_len % 256;
      request.length = request.length + 2;
      
      // Topic name
      let char_idx: int = 0;
      let copy_topic_done: int = 0;
      while (copy_topic_done == 0) {
        if (char_idx >= topic_len) {
          copy_topic_done = 1;
        } else {
          request.data[request.length] = char_to_ascii(topic[char_idx]);
          request.length = request.length + 1;
          char_idx = char_idx + 1;
        }
      }
      
      // Partition array count
      request.data[request.length] = 0;
      request.data[request.length + 1] = partition_count;
      request.length = request.length + 2;
      
      // Encode each partition
      let part_idx: int = 0;
      let encode_parts_done: int = 0;
      while (encode_parts_done == 0) {
        if (part_idx >= partition_count) {
          encode_parts_done = 1;
        } else {
          // Partition ID
          let partition_id: int = partitions[part_idx];
          request.data[request.length] = partition_id / 256;
          request.data[request.length + 1] = partition_id % 256;
          request.length = request.length + 2;
          
          // Message set size (placeholder)
          let msg_set_size_pos: int = request.length;
          request.length = request.length + 4;
          
          // Encode messages for this partition
          let msg_start_pos: int = request.length;
          let msg_idx: int = 0;
          let encode_msgs_done: int = 0;
          
          while (encode_msgs_done == 0) {
            if (msg_idx >= message_count) {
              encode_msgs_done = 1;
            } else {
              let message: Message = messages[msg_idx];
              
              // Message offset (int64)
              let offset: int = message.offset;
              request.data[request.length] = offset / 16777216 / 16777216;
              request.data[request.length + 1] = (offset / 16777216) % 256;
              request.data[request.length + 2] = (offset / 65536) % 256;
              request.data[request.length + 3] = (offset / 256) % 256;
              request.data[request.length + 4] = (offset / 256) % 256;
              request.data[request.length + 5] = (offset / 256) % 256;
              request.data[request.length + 6] = (offset / 256) % 256;
              request.data[request.length + 7] = offset % 256;
              request.length = request.length + 8;
              
              // Message size (placeholder)
              let msg_size_pos: int = request.length;
              request.length = request.length + 4;
              
              // CRC (placeholder)
              request.data[request.length] = 0;
              request.data[request.length + 1] = 0;
              request.data[request.length + 2] = 0;
              request.data[request.length + 3] = 0;
              request.length = request.length + 4;
              
              // Magic byte
              request.data[request.length] = 2;
              request.length = request.length + 1;
              
              // Attributes
              request.data[request.length] = message.compression;
              request.length = request.length + 1;
              
              // Timestamp
              let timestamp: int = message.timestamp;
              request.data[request.length] = timestamp / 16777216 / 16777216;
              request.data[request.length + 1] = (timestamp / 16777216) % 256;
              request.data[request.length + 2] = (timestamp / 65536) % 256;
              request.data[request.length + 3] = (timestamp / 256) % 256;
              request.data[request.length + 4] = (timestamp / 256) % 256;
              request.data[request.length + 5] = (timestamp / 256) % 256;
              request.data[request.length + 6] = (timestamp / 256) % 256;
              request.data[request.length + 7] = timestamp % 256;
              request.length = request.length + 8;
              
              // Key length
              let key_len: int = message.key_length;
              request.data[request.length] = key_len / 256;
              request.data[request.length + 1] = key_len % 256;
              request.length = request.length + 2;
              
              // Key
              let key_idx: int = 0;
              let copy_key_done: int = 0;
              while (copy_key_done == 0) {
                if (key_idx >= key_len) {
                  copy_key_done = 1;
                } else {
                  request.data[request.length] = message.key[key_idx];
                  request.length = request.length + 1;
                  key_idx = key_idx + 1;
                }
              }
              
              // Value length
              let value_len: int = message.value_length;
              request.data[request.length] = value_len / 256;
              request.data[request.length + 1] = value_len % 256;
              request.length = request.length + 2;
              
              // Value
              let value_idx: int = 0;
              let copy_value_done: int = 0;
              while (copy_value_done == 0) {
                if (value_idx >= value_len) {
                  copy_value_done = 1;
                } else {
                  request.data[request.length] = message.value[value_idx];
                  request.length = request.length + 1;
                  value_idx = value_idx + 1;
                }
              }
              
              // Calculate message size and update
              let msg_size: int = request.length - msg_size_pos - 4;
              request.data[msg_size_pos] = msg_size / 16777216;
              request.data[msg_size_pos + 1] = (msg_size / 65536) % 256;
              request.data[msg_size_pos + 2] = (msg_size / 256) % 256;
              request.data[msg_size_pos + 3] = msg_size % 256;
              
              // Calculate CRC (simplified)
              let crc_data: [8192]int = [8192]int{0};
              let crc_idx: int = 0;
              let copy_crc_done: int = 0;
              while (copy_crc_done == 0) {
                if (crc_idx >= msg_size || (msg_size_pos + 4 + crc_idx) >= request.length) {
                  copy_crc_done = 1;
                } else {
                  crc_data[crc_idx] = request.data[msg_size_pos + 4 + crc_idx];
                  crc_idx = crc_idx + 1;
                }
              }
              
              let checksum: int = simple_checksum(crc_data, crc_idx);
              request.data[msg_size_pos + 4] = checksum / 16777216;
              request.data[msg_size_pos + 5] = (checksum / 65536) % 256;
              request.data[msg_size_pos + 6] = (checksum / 256) % 256;
              request.data[msg_size_pos + 7] = checksum % 256;
              
              msg_idx = msg_idx + 1;
            }
          }
          
          // Update message set size
          let msg_set_size: int = request.length - msg_start_pos;
          request.data[msg_set_size_pos] = msg_set_size / 16777216;
          request.data[msg_set_size_pos + 1] = (msg_set_size / 65536) % 256;
          request.data[msg_set_size_pos + 2] = (msg_set_size / 256) % 256;
          request.data[msg_set_size_pos + 3] = msg_set_size % 256;
          
          part_idx = part_idx + 1;
        }
      }
      
      topic_idx = topic_idx + 1;
    }
  }
  
  return request;
}

func decode_produce_response(data: [65536]int, length: int) KafkaResponse {
  let response: KafkaResponse = KafkaResponse{
    header: decode_kafka_header(data, 0),
    data: data,
    length: length,
    error_code: ERROR_NONE,
  };
  
  // Skip header (find where it ends)
  let offset: int = 0;
  let client_id_len: int = data[8] * 256 + data[9];
  offset = 10 + client_id_len;
  
  // Response starts here
  // Throttle time (skip)
  offset = offset + 4;
  
  // Topic array count
  let topic_count: int = data[offset] * 256 + data[offset + 1];
  offset = offset + 2;
  
  // Parse topics
  let topic_idx: int = 0;
  let parse_topics_done: int = 0;
  while (parse_topics_done == 0) {
    if (topic_idx >= topic_count) {
      parse_topics_done = 1;
    } else {
      // Topic name length
      let topic_name_len: int = data[offset] * 256 + data[offset + 1];
      offset = offset + 2;
      
      // Skip topic name
      offset = offset + topic_name_len;
      
      // Partition array count
      let partition_count: int = data[offset] * 256 + data[offset + 1];
      offset = offset + 2;
      
      // Parse partitions
      let part_idx: int = 0;
      let parse_parts_done: int = 0;
      while (parse_parts_done == 0) {
        if (part_idx >= partition_count) {
          parse_parts_done = 1;
        } else {
          // Partition ID
          let partition_id: int = data[offset] * 256 + data[offset + 1];
          offset = offset + 2;
          
          // Error code
          let error_code: int = data[offset] * 256 + data[offset + 1];
          offset = offset + 2;
          
          if (error_code != ERROR_NONE) {
            response.error_code = error_code;
          }
          
          // Base offset
          let base_offset: int = data[offset] * 16777216 * 16777216 +
                                data[offset + 1] * 16777216 +
                                data[offset + 2] * 65536 +
                                data[offset + 3] * 256 +
                                data[offset + 4] * 256 +
                                data[offset + 5] * 256 +
                                data[offset + 6] * 256 +
                                data[offset + 7];
          offset = offset + 8;
          
          // Timestamp
          offset = offset + 8;
          
          part_idx = part_idx + 1;
        }
      }
      
      topic_idx = topic_idx + 1;
    }
  }
  
  return response;
}

func encode_fetch_request(topics: [10]string, topic_count: int,
                         partitions: [10]int, partition_count: int,
                         offsets: [10]int, max_bytes: int,
                         correlation_id: int, client_id: string) KafkaRequest {
  let request: KafkaRequest = KafkaRequest{
    header: KafkaHeader{api_key: 0, api_version: 0, correlation_id: 0, client_id: ""},
    data: [65536]int{0},
    length: 0,
  };
  
  // Encode header
  let header_data: [1024]int = encode_kafka_header(API_KEY_FETCH, 3, correlation_id, client_id);
  
  // Copy header to request
  let idx: int = 0;
  let copy_header_done: int = 0;
  while (copy_header_done == 0) {
    if (idx >= 1024 || header_data[idx] == 0) {
      copy_header_done = 1;
    } else {
      request.data[idx] = header_data[idx];
      idx = idx + 1;
    }
  }
  
  request.length = idx;
  
  // Replica ID (-1 for consumer)
  request.data[request.length] = 255;
  request.data[request.length + 1] = 255;
  request.length = request.length + 4;
  
  // Max wait time (100 ms)
  request.data[request.length] = 0;
  request.data[request.length + 1] = 0;
  request.data[request.length + 2] = 0;
  request.data[request.length + 3] = 100;
  request.length = request.length + 4;
  
  // Min bytes (1)
  request.data[request.length] = 0;
  request.data[request.length + 1] = 1;
  request.length = request.length + 4;
  
  // Max bytes
  request.data[request.length] = max_bytes / 16777216;
  request.data[request.length + 1] = (max_bytes / 65536) % 256;
  request.data[request.length + 2] = (max_bytes / 256) % 256;
  request.data[request.length + 3] = max_bytes % 256;
  request.length = request.length + 4;
  
  // Topic array count
  request.data[request.length] = 0;
  request.data[request.length + 1] = topic_count;
  request.length = request.length + 2;
  
  // Encode each topic
  let topic_idx: int = 0;
  let encode_topics_done: int = 0;
  while (encode_topics_done == 0) {
    if (topic_idx >= topic_count) {
      encode_topics_done = 1;
    } else {
      let topic: string = topics[topic_idx];
      
      // Topic name length
      let topic_len: int = topic.length;
      request.data[request.length] = topic_len / 256;
      request.data[request.length + 1] = topic_len % 256;
      request.length = request.length + 2;
      
      // Topic name
      let char_idx: int = 0;
      let copy_topic_done: int = 0;
      while (copy_topic_done == 0) {
        if (char_idx >= topic_len) {
          copy_topic_done = 1;
        } else {
          request.data[request.length] = char_to_ascii(topic[char_idx]);
          request.length = request.length + 1;
          char_idx = char_idx + 1;
        }
      }
      
      // Partition array count
      request.data[request.length] = 0;
      request.data[request.length + 1] = partition_count;
      request.length = request.length + 2;
      
      // Encode each partition
      let part_idx: int = 0;
      let encode_parts_done: int = 0;
      while (encode_parts_done == 0) {
        if (part_idx >= partition_count) {
          encode_parts_done = 1;
        } else {
          // Partition ID
          let partition_id: int = partitions[part_idx];
          request.data[request.length] = partition_id / 256;
          request.data[request.length + 1] = partition_id % 256;
          request.length = request.length + 2;
          
          // Current offset
          let current_offset: int = offsets[part_idx];
          request.data[request.length] = current_offset / 16777216 / 16777216;
          request.data[request.length + 1] = (current_offset / 16777216) % 256;
          request.data[request.length + 2] = (current_offset / 65536) % 256;
          request.data[request.length + 3] = (current_offset / 256) % 256;
          request.data[request.length + 4] = (current_offset / 256) % 256;
          request.data[request.length + 5] = (current_offset / 256) % 256;
          request.data[request.length + 6] = (current_offset / 256) % 256;
          request.data[request.length + 7] = current_offset % 256;
          request.length = request.length + 8;
          
          // Log start offset (0)
          request.data[request.length] = 0;
          request.data[request.length + 1] = 0;
          request.data[request.length + 2] = 0;
          request.data[request.length + 3] = 0;
          request.data[request.length + 4] = 0;
          request.data[request.length + 5] = 0;
          request.data[request.length + 6] = 0;
          request.data[request.length + 7] = 0;
          request.length = request.length + 8;
          
          // Max bytes for this partition
          request.data[request.length] = max_bytes / 16777216;
          request.data[request.length + 1] = (max_bytes / 65536) % 256;
          request.data[request.length + 2] = (max_bytes / 256) % 256;
          request.data[request.length + 3] = max_bytes % 256;
          request.length = request.length + 4;
          
          part_idx = part_idx + 1;
        }
      }
      
      topic_idx = topic_idx + 1;
    }
  }
  
  return request;
}

func decode_fetch_response(data: [65536]int, length: int) [100]Record {
  let records: [100]Record = [100]Record{};
  let record_count: int = 0;
  
  // Skip to response data
  let offset: int = 0;
  
  // Skip header
  let client_id_len: int = data[8] * 256 + data[9];
  offset = 10 + client_id_len;
  
  // Throttle time
  offset = offset + 4;
  
  // Topic array count
  let topic_count: int = data[offset] * 256 + data[offset + 1];
  offset = offset + 2;
  
  // Parse topics
  let topic_idx: int = 0;
  let parse_topics_done: int = 0;
  while (parse_topics_done == 0) {
    if (topic_idx >= topic_count) {
      parse_topics_done = 1;
    } else {
      // Topic name length
      let topic_name_len: int = data[offset] * 256 + data[offset + 1];
      offset = offset + 2;
      
      // Topic name
      let topic_name: string = "";
      let char_idx: int = 0;
      let build_topic_done: int = 0;
      while (build_topic_done == 0) {
        if (char_idx >= topic_name_len) {
          build_topic_done = 1;
        } else {
          topic_name = topic_name + ascii_to_char(data[offset]);
          offset = offset + 1;
          char_idx = char_idx + 1;
        }
      }
      
      // Partition array count
      let partition_count: int = data[offset] * 256 + data[offset + 1];
      offset = offset + 2;
      
      // Parse partitions
      let part_idx: int = 0;
      let parse_parts_done: int = 0;
      while (parse_parts_done == 0) {
        if (part_idx >= partition_count) {
          parse_parts_done = 1;
        } else {
          // Partition ID
          let partition_id: int = data[offset] * 256 + data[offset + 1];
          offset = offset + 2;
          
          // Error code
          let error_code: int = data[offset] * 256 + data[offset + 1];
          offset = offset + 2;
          
          // High watermark offset
          offset = offset + 8;
          
          // Last stable offset
          offset = offset + 8;
          
          // Log start offset
          offset = offset + 8;
          
          // Aborted transactions length
          let aborted_len: int = data[offset] * 256 + data[offset + 1];
          offset = offset + 2;
          
          // Skip aborted transactions
          offset = offset + aborted_len;
          
          // Record batch length
          let batch_len: int = data[offset] * 16777216 +
                              data[offset + 1] * 65536 +
                              data[offset + 2] * 256 +
                              data[offset + 3];
          offset = offset + 4;
          
          if (batch_len > 0) {
            let batch_end: int = offset + batch_len;
            
            // Parse record batch
            while (offset < batch_end && record_count < 100) {
              // Check if we have enough data for a record
              if (offset + 50 > length) {
                offset = batch_end;
              } else {
                // Parse a message (simplified)
                let message_offset: int = offset;
                
                // Skip to value
                let value_offset: int = offset + 40; // Approximate
                
                // Try to parse key and value
                let key_len_pos: int = value_offset - 2;
                let key_len: int = data[key_len_pos] * 256 + data[key_len_pos + 1];
                
                let value_len_pos: int = value_offset + key_len;
                let value_len: int = data[value_len_pos] * 256 + data[value_len_pos + 1];
                
                if (key_len > 0 || value_len > 0) {
                  // Extract key
                  let key_str: string = "";
                  if (key_len > 0) {
                    let key_start: int = value_offset;
                    let ki: int = 0;
                    let extract_key_done: int = 0;
                    while (extract_key_done == 0) {
                      if (ki >= key_len || key_start + ki >= length) {
                        extract_key_done = 1;
                      } else {
                        key_str = key_str + ascii_to_char(data[key_start + ki]);
                        ki = ki + 1;
                      }
                    }
                  }
                  
                  // Extract value
                  let value_str: string = "";
                  if (value_len > 0) {
                    let value_start: int = value_len_pos + 2;
                    let vi: int = 0;
                    let extract_value_done: int = 0;
                    while (extract_value_done == 0) {
                      if (vi >= value_len || value_start + vi >= length) {
                        extract_value_done = 1;
                      } else {
                        value_str = value_str + ascii_to_char(data[value_start + vi]);
                        vi = vi + 1;
                      }
                    }
                  }
                  
                  // Create record
                  records[record_count] = Record{
                    topic: topic_name,
                    partition: partition_id,
                    offset: 0, // Would be parsed from message
                    timestamp: 0, // Would be parsed from message
                    key: key_str,
                    value: value_str,
                  };
                  record_count = record_count + 1;
                }
                
                // Move to next message (simplified)
                offset = offset + 100;
              }
            }
          }
          
          part_idx = part_idx + 1;
        }
      }
      
      topic_idx = topic_idx + 1;
    }
  }
  
  return records;
}

// ==================== BROKER AND CLUSTER MANAGEMENT ====================

func create_cluster() ClusterMetadata {
  let cluster: ClusterMetadata = ClusterMetadata{
    brokers: [100]Broker{},
    broker_count: 0,
    topics: [100]TopicMetadata{},
    topic_count: 0,
    controller_id: 0,
  };
  
  // Create some default brokers
  cluster.brokers[0] = Broker{
    id: 1,
    host: "localhost",
    port: 9092,
    rack: "rack1",
    is_alive: 1,
  };
  cluster.broker_count = cluster.broker_count + 1;
  
  cluster.brokers[1] = Broker{
    id: 2,
    host: "localhost",
    port: 9093,
    rack: "rack1",
    is_alive: 1,
  };
  cluster.broker_count = cluster.broker_count + 1;
  
  cluster.brokers[2] = Broker{
    id: 3,
    host: "localhost",
    port: 9094,
    rack: "rack2",
    is_alive: 1,
  };
  cluster.broker_count = cluster.broker_count + 1;
  
  cluster.controller_id = 1;
  
  return cluster;
}

func create_topic_metadata(cluster: *ClusterMetadata, topic_name: string, partition_count: int, replication_factor: int) int {
  if (cluster.topic_count >= 100) {
    return ERROR_UNKNOWN;
  }
  
  let topic_meta: TopicMetadata = TopicMetadata{
    topic: topic_name,
    partitions: [100]PartitionMetadata{},
    partition_count: 0,
    error_code: ERROR_NONE,
  };
  
  // Create partitions
  let part_idx: int = 0;
  let create_parts_done: int = 0;
  while (create_parts_done == 0) {
    if (part_idx >= partition_count) {
      create_parts_done = 1;
    } else {
      // Simple leader assignment
      let leader_id: int = (part_idx % cluster.broker_count) + 1;
      
      // Create replicas
      let replicas: [10]int = [10]int{0};
      let replica_count: int = 0;
      let rep_idx: int = 0;
      let assign_replicas_done: int = 0;
      
      while (assign_replicas_done == 0) {
        if (replica_count >= replication_factor || replica_count >= cluster.broker_count) {
          assign_replicas_done = 1;
        } else {
          let broker_id: int = (part_idx + rep_idx) % cluster.broker_count + 1;
          replicas[replica_count] = broker_id;
          replica_count = replica_count + 1;
          rep_idx = rep_idx + 1;
        }
      }
      
      // ISR same as replicas for now
      let isr: [10]int = [10]int{0};
      let isr_count: int = replica_count;
      let isr_idx: int = 0;
      let copy_isr_done: int = 0;
      
      while (copy_isr_done == 0) {
        if (isr_idx >= isr_count) {
          copy_isr_done = 1;
        } else {
          isr[isr_idx] = replicas[isr_idx];
          isr_idx = isr_idx + 1;
        }
      }
      
      topic_meta.partitions[part_idx] = PartitionMetadata{
        partition: part_idx,
        leader: leader_id,
        replicas: replicas,
        replica_count: replica_count,
        isr: isr,
        isr_count: isr_count,
        error_code: ERROR_NONE,
      };
      topic_meta.partition_count = topic_meta.partition_count + 1;
      
      part_idx = part_idx + 1;
    }
  }
  
  cluster.topics[cluster.topic_count] = topic_meta;
  cluster.topic_count = cluster.topic_count + 1;
  
  return ERROR_NONE;
}

func get_topic_metadata(cluster: ClusterMetadata, topic_name: string) TopicMetadata {
  let empty_meta: TopicMetadata = TopicMetadata{
    topic: "",
    partitions: [100]PartitionMetadata{},
    partition_count: 0,
    error_code: ERROR_UNKNOWN_TOPIC_OR_PARTITION,
  };
  
  let i: int = 0;
  let search_done: int = 0;
  
  while (search_done == 0) {
    if (i >= cluster.topic_count) {
      search_done = 1;
    } else {
      if (cluster.topics[i].topic == topic_name) {
        return cluster.topics[i];
      }
      i = i + 1;
    }
  }
  
  return empty_meta;
}

// ==================== PRODUCER IMPLEMENTATION ====================

struct Producer {
  cluster: ClusterMetadata,
  client_id: string,
  correlation_counter: int,
  acks: int,
  timeout_ms: int,
  compression_type: int,
  batch_size: int,
}

func create_producer(client_id: string) Producer {
  let producer: Producer = Producer{
    cluster: create_cluster(),
    client_id: client_id,
    correlation_counter: 1,
    acks: 1,
    timeout_ms: 30000,
    compression_type: COMPRESSION_NONE,
    batch_size: 16384,
  };
  
  // Create some default topics
  create_topic_metadata(producer.cluster, "test-topic", 3, 2);
  create_topic_metadata(producer.cluster, "events", 5, 3);
  create_topic_metadata(producer.cluster, "logs", 1, 1);
  
  return producer;
}

func producer_send(producer: *Producer, topic: string, partition: int, 
                  key: string, value: string) KafkaResponse {
  // Get topic metadata
  let topic_meta: TopicMetadata = get_topic_metadata(producer.cluster, topic);
  
  if (topic_meta.error_code != ERROR_NONE) {
    let error_response: KafkaResponse = KafkaResponse{
      header: KafkaHeader{api_key: API_KEY_PRODUCE, api_version: 2, 
                         correlation_id: producer.correlation_counter, 
                         client_id: producer.client_id},
      data: [65536]int{0},
      length: 0,
      error_code: topic_meta.error_code,
    };
    producer.correlation_counter = producer.correlation_counter + 1;
    return error_response;
  }
  
  // Check partition exists
  if (partition < 0 || partition >= topic_meta.partition_count) {
    let error_response: KafkaResponse = KafkaResponse{
      header: KafkaHeader{api_key: API_KEY_PRODUCE, api_version: 2, 
                         correlation_id: producer.correlation_counter, 
                         client_id: producer.client_id},
      data: [65536]int{0},
      length: 0,
      error_code: ERROR_UNKNOWN_TOPIC_OR_PARTITION,
    };
    producer.correlation_counter = producer.correlation_counter + 1;
    return error_response;
  }
  
  // Create message
  let message: Message = Message{
    offset: 0, // Will be assigned by broker
    timestamp: 1234567890, // Would be current timestamp
    key: string_to_ascii_array(key),
    key_length: key.length,
    value: string_to_ascii_array(value),
    value_length: value.length,
    compression: producer.compression_type,
    checksum: 0, // Will be calculated
    partition: partition,
  };
  
  // Calculate checksum
  let checksum_data: [8192]int = [8192]int{0};
  let data_idx: int = 0;
  
  // Copy key
  let key_idx: int = 0;
  let copy_key_done: int = 0;
  while (copy_key_done == 0) {
    if (key_idx >= message.key_length) {
      copy_key_done = 1;
    } else {
      checksum_data[data_idx] = message.key[key_idx];
      data_idx = data_idx + 1;
      key_idx = key_idx + 1;
    }
  }
  
  // Copy value
  let value_idx: int = 0;
  let copy_value_done: int = 0;
  while (copy_value_done == 0) {
    if (value_idx >= message.value_length) {
      copy_value_done = 1;
    } else {
      checksum_data[data_idx] = message.value[value_idx];
      data_idx = data_idx + 1;
      value_idx = value_idx + 1;
    }
  }
  
  message.checksum = simple_checksum(checksum_data, data_idx);
  
  // Prepare request
  let topics: [10]string = [10]string{topic, "", "", "", "", "", "", "", "", ""};
  let partitions_arr: [10]int = [10]int{partition, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  let messages_arr: [100]Message = [100]Message{message};
  
  let request: KafkaRequest = encode_produce_request(topics, 1, partitions_arr, 1, 
                                                    messages_arr, 1, 
                                                    producer.correlation_counter, 
                                                    producer.client_id);
  
  // Simulate sending to broker (in real implementation, this would be network)
  let response: KafkaResponse = decode_produce_response(request.data, request.length);
  
  producer.correlation_counter = producer.correlation_counter + 1;
  return response;
}

// ==================== CONSUMER IMPLEMENTATION ====================

struct Consumer {
  cluster: ClusterMetadata,
  group_id: string,
  client_id: string,
  correlation_counter: int,
  topics: [10]string,
  topic_count: int,
  offsets: [100]int, // topic*partition -> offset
  auto_offset_reset: int, // 0=earliest, 1=latest
  enable_auto_commit: int,
  fetch_min_bytes: int,
  fetch_max_wait_ms: int,
}

func create_consumer(group_id: string, client_id: string) Consumer {
  let consumer: Consumer = Consumer{
    cluster: create_cluster(),
    group_id: group_id,
    client_id: client_id,
    correlation_counter: 1,
    topics: [10]string{"", "", "", "", "", "", "", "", "", ""},
    topic_count: 0,
    offsets: [100]int{0},
    auto_offset_reset: 0, // earliest
    enable_auto_commit: 1,
    fetch_min_bytes: 1,
    fetch_max_wait_ms: 100,
  };
  
  return consumer;
}

func consumer_subscribe(consumer: *Consumer, topic: string) int {
  if (consumer.topic_count >= 10) {
    return ERROR_UNKNOWN;
  }
  
  consumer.topics[consumer.topic_count] = topic;
  consumer.topic_count = consumer.topic_count + 1;
  
  return ERROR_NONE;
}

func consumer_poll(consumer: *Consumer, timeout_ms: int) [100]Record {
  let empty_records: [100]Record = [100]Record{};
  
  if (consumer.topic_count == 0) {
    return empty_records;
  }
  
  // For each subscribed topic, fetch messages
  let all_records: [100]Record = [100]Record{};
  let total_records: int = 0;
  
  let topic_idx: int = 0;
  let poll_topics_done: int = 0;
  
  while (poll_topics_done == 0) {
    if (topic_idx >= consumer.topic_count) {
      poll_topics_done = 1;
    } else {
      let topic: string = consumer.topics[topic_idx];
      let topic_meta: TopicMetadata = get_topic_metadata(consumer.cluster, topic);
      
      if (topic_meta.error_code == ERROR_NONE) {
        // Fetch from all partitions
        let part_idx: int = 0;
        let poll_parts_done: int = 0;
        
        while (poll_parts_done == 0) {
          if (part_idx >= topic_meta.partition_count || total_records >= 100) {
            poll_parts_done = 1;
          } else {
            // Get current offset for this partition
            let offset_key: int = topic_idx * 10 + part_idx;
            let current_offset: int = consumer.offsets[offset_key];
            
            if (current_offset == 0 && consumer.auto_offset_reset == 1) {
              current_offset = OFFSET_LATEST;
            }
            
            // Prepare fetch request
            let topics_arr: [10]string = [10]string{topic, "", "", "", "", "", "", "", "", ""};
            let partitions_arr: [10]int = [10]int{part_idx, 0, 0, 0, 0, 0, 0, 0, 0, 0};
            let offsets_arr: [10]int = [10]int{current_offset, 0, 0, 0, 0, 0, 0, 0, 0, 0};
            
            let request: KafkaRequest = encode_fetch_request(topics_arr, 1, partitions_arr, 1,
                                                            offsets_arr, 65536,
                                                            consumer.correlation_counter,
                                                            consumer.client_id);
            
            // Simulate fetch
            let records: [100]Record = decode_fetch_response(request.data, request.length);
            
            // Process records
            let rec_idx: int = 0;
            let process_records_done: int = 0;
            
            while (process_records_done == 0) {
              if (rec_idx >= 100 || records[rec_idx].topic == "") {
                process_records_done = 1;
              } else {
                all_records[total_records] = records[rec_idx];
                total_records = total_records + 1;
                
                // Update offset
                consumer.offsets[offset_key] = consumer.offsets[offset_key] + 1;
                
                rec_idx = rec_idx + 1;
              }
            }
            
            consumer.correlation_counter = consumer.correlation_counter + 1;
            part_idx = part_idx + 1;
          }
        }
      }
      
      topic_idx = topic_idx + 1;
    }
  }
  
  return all_records;
}

func consumer_commit(consumer: *Consumer) int {
  // In a real implementation, this would send offset commit requests
  // For now, just acknowledge the operation
  return ERROR_NONE;
}

// ==================== TOPIC ADMINISTRATION ====================

func create_topic(cluster: *ClusterMetadata, topic_name: string, 
                 num_partitions: int, replication_factor: int) int {
  // Check if topic already exists
  let i: int = 0;
  let check_done: int = 0;
  
  while (check_done == 0) {
    if (i >= cluster.topic_count) {
      check_done = 1;
    } else {
      if (cluster.topics[i].topic == topic_name) {
        return ERROR_INVALID_CONFIG; // Topic already exists
      }
      i = i + 1;
    }
  }
  
  // Validate parameters
  if (num_partitions <= 0) {
    return ERROR_INVALID_CONFIG;
  }
  
  if (replication_factor <= 0 || replication_factor > cluster.broker_count) {
    return ERROR_INVALID_CONFIG;
  }
  
  // Create topic
  return create_topic_metadata(cluster, topic_name, num_partitions, replication_factor);
}

func delete_topic(cluster: *ClusterMetadata, topic_name: string) int {
  // Find topic
  let topic_idx: int = -1;
  let i: int = 0;
  let search_done: int = 0;
  
  while (search_done == 0) {
    if (i >= cluster.topic_count) {
      search_done = 1;
    } else {
      if (cluster.topics[i].topic == topic_name) {
        topic_idx = i;
        search_done = 1;
      }
      i = i + 1;
    }
  }
  
  if (topic_idx == -1) {
    return ERROR_UNKNOWN_TOPIC_OR_PARTITION;
  }
  
  // Shift topics array
  let shift_idx: int = topic_idx;
  let shift_done: int = 0;
  
  while (shift_done == 0) {
    if (shift_idx >= cluster.topic_count - 1) {
      shift_done = 1;
    } else {
      cluster.topics[shift_idx] = cluster.topics[shift_idx + 1];
      shift_idx = shift_idx + 1;
    }
  }
  
  cluster.topic_count = cluster.topic_count - 1;
  
  return ERROR_NONE;
}

// ==================== MAIN TEST PROGRAM ====================

start() int {
  print("=========================================");
  print("KAFKA-LITE PROTOCOL IMPLEMENTATION");
  print("=========================================");
  
  print("");
  print("TEST 1: CLUSTER INITIALIZATION");
  print("------------------------------");
  
  let cluster: ClusterMetadata = create_cluster();
  print("Cluster created with ", cluster.broker_count, " brokers");
  print("Controller ID: ", cluster.controller_id);
  
  let broker_idx: int = 0;
  let print_brokers_done: int = 0;
  while (print_brokers_done == 0) {
    if (broker_idx >= cluster.broker_count) {
      print_brokers_done = 1;
    } else {
      let broker: Broker = cluster.brokers[broker_idx];
      print("  Broker ", broker.id, ": ", broker.host, ":", broker.port, 
            " (rack: ", broker.rack, ", alive: ", broker.is_alive, ")");
      broker_idx = broker_idx + 1;
    }
  }
  
  print("");
  print("TEST 2: TOPIC CREATION");
  print("---------------------");
  
  let create_result: int = create_topic(cluster, "test-topic", 3, 2);
  print("Create topic 'test-topic': ", get_error_name(create_result));
  
  create_result = create_topic(cluster, "events", 5, 3);
  print("Create topic 'events': ", get_error_name(create_result));
  
  create_result = create_topic(cluster, "logs", 1, 1);
  print("Create topic 'logs': ", get_error_name(create_result));
  
  print("");
  print("Cluster now has ", cluster.topic_count, " topics");
  
  let topic_idx: int = 0;
  let print_topics_done: int = 0;
  while (print_topics_done == 0) {
    if (topic_idx >= cluster.topic_count) {
      print_topics_done = 1;
    } else {
      let topic: TopicMetadata = cluster.topics[topic_idx];
      print("  Topic '", topic.topic, "': ", topic.partition_count, " partitions");
      
      let part_idx: int = 0;
      let print_parts_done: int = 0;
      while (print_parts_done == 0) {
        if (part_idx >= topic.partition_count) {
          print_parts_done = 1;
        } else {
          let partition: PartitionMetadata = topic.partitions[part_idx];
          print("    Partition ", partition.partition, ": leader=", partition.leader);
          
          let replica_str: string = "replicas=[";
          let rep_idx: int = 0;
          let build_replicas_done: int = 0;
          while (build_replicas_done == 0) {
            if (rep_idx >= partition.replica_count) {
              build_replicas_done = 1;
            } else {
              if (rep_idx > 0) {
                replica_str = replica_str + ",";
              }
              replica_str = replica_str + int_to_string(partition.replicas[rep_idx]);
              rep_idx = rep_idx + 1;
            }
          }
          replica_str = replica_str + "]";
          print("      ", replica_str);
          
          part_idx = part_idx + 1;
        }
      }
      
      topic_idx = topic_idx + 1;
    }
  }
  
  print("");
  print("TEST 3: PRODUCER OPERATIONS");
  print("---------------------------");
  
  let producer: Producer = create_producer("test-producer");
  print("Producer created with client_id: ", producer.client_id);
  
  // Send messages
  print("");
  print("Sending messages to 'test-topic':");
  
  let message_num: int = 1;
  let send_done: int = 0;
  while (send_done == 0) {
    if (message_num > 3) {
      send_done = 1;
    } else {
      let key: string = "key" + int_to_string(message_num);
      let value: string = "Message " + int_to_string(message_num) + " from producer";
      
      print("  Sending message ", message_num, " (key: ", key, ")");
      let response: KafkaResponse = producer_send(producer, "test-topic", 0, key, value);
      
      if (response.error_code == ERROR_NONE) {
        print("    Success! Correlation ID: ", response.header.correlation_id);
      } else {
        print("    Error: ", get_error_name(response.error_code));
      }
      
      message_num = message_num + 1;
    }
  }
  
  print("");
  print("TEST 4: CONSUMER OPERATIONS");
  print("---------------------------");
  
  let consumer: Consumer = create_consumer("test-group", "test-consumer");
  print("Consumer created with group_id: ", consumer.group_id);
  
  let subscribe_result: int = consumer_subscribe(consumer, "test-topic");
  print("Subscribe to 'test-topic': ", get_error_name(subscribe_result));
  
  subscribe_result = consumer_subscribe(consumer, "events");
  print("Subscribe to 'events': ", get_error_name(subscribe_result));
  
  print("");
  print("Polling for messages:");
  let records: [100]Record = consumer_poll(consumer, 1000);
  
  let record_idx: int = 0;
  let print_records_done: int = 0;
  while (print_records_done == 0) {
    if (record_idx >= 100 || records[record_idx].topic == "") {
      print_records_done = 1;
    } else {
      let record: Record = records[record_idx];
    }
  }

  return 0;
}
